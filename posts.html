<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>(wat-aro) | Posts</title><meta name="next-head-count" content="3"/><link rel="icon" href="/images/favicon.ico"/><link rel="preload" href="/_next/static/css/afae555b5c3d7721.css" as="style"/><link rel="stylesheet" href="/_next/static/css/afae555b5c3d7721.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f57e918ec4214daa.js" defer=""></script><script src="/_next/static/chunks/pages/posts-509cf1af72ad6ea0.js" defer=""></script><script src="/_next/static/ylF5aIAZfEQnuFW-xnevL/_buildManifest.js" defer=""></script><script src="/_next/static/ylF5aIAZfEQnuFW-xnevL/_ssgManifest.js" defer=""></script><script src="/_next/static/ylF5aIAZfEQnuFW-xnevL/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="py-0 md:px-8 min-h-screen flex flex-col items-center"><div class="sticky top-0 bg-white w-full h-16 flex flex-row justify-between items-center px-4 border-b-2"><div class="flex items-center font-midium text-3xl h-full"><a href="/">(wat-aro)</a></div><ul class="flex gap-3 h-full"><li class="h-full  flex flex-col justify-end border-black pb-4"><a href="/about">About</a></li><li class="h-full  flex flex-col justify-end border-black pb-3 border-b-4"><a href="/posts">Blog</a></li></ul></div><div class="flex md:justify-center justify-between w-full"><div class="flex flex-col md:w-9/12 w-full py-4 px-4"><h1 class="text-3xl mb-8">Posts</h1><a class="hover:border-b-2" href="/posts/feeling-to-type-ruby"><div class="flex pt-2 pb-1 justify-between"><div class="text-xl md:w-5/6 w-9/12">Ruby に型をつけるお気持ち</div><div class="text-gray-500 md:w-1/6 w-3/12 flex justify-end">2020-01-15</div></div></a><a class="hover:border-b-2" href="/posts/getting-started-with-elm"><div class="flex pt-2 pb-1 justify-between"><div class="text-xl md:w-5/6 w-9/12">Elm ことはじめ</div><div class="text-gray-500 md:w-1/6 w-3/12 flex justify-end">2019-10-28</div></div></a><a class="hover:border-b-2" href="/posts/pipeline-operator"><div class="flex pt-2 pb-1 justify-between"><div class="text-xl md:w-5/6 w-9/12">パイプライン演算子</div><div class="text-gray-500 md:w-1/6 w-3/12 flex justify-end">2019-06-20</div></div></a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"data":{"title":"Ruby に型をつけるお気持ち","published":"2020-01-15"},"content":"\n# Ruby に型をつけるお気持ち\n\nwat-aro\n\n---\n\n## 自己紹介\n\n- wat-aro\n- Haskell, Elm なんかが好き\n\n---\n\n## おしながき\n\n- Ruby の型のおさらい\n- ruby-signature の記法\n- 実例を通して\n\n---\n\n### `Ruby` の型のおさらい\n\n- 型検査器 steep, sorbet\n- rbi ファイルに型定義を書くがそれぞれ文法が違う\n- Ruby 3 では型シグネチャが導入される\n- 周辺ツール群は外部ライブラリとして提供\n\n---\n\n### `Ruby` の型シグナチャ\n\n- ruby-signature\n- https://github.com/ruby/ruby-signature\n- steep, sorbet にこのシグネチャを使ってもらう\n\n---\n\n---\n\n## `ruby-signature` の記法\n\n- プリミティブな型は Class instance type で定義\n- Interface type であるメソッドを持った型というのも定義できる\n- Literal type, Union Type, Intersection type, Optional type で柔軟な型定義ができる\n- ivar や メソッドの型定義も直観的\n- 型付けできないものは `untyped`\n\n---\n\n### プリミティブな型\n\n- Integer\n- String\n- Hash[Symbol, String]\n\n---\n\n### `Record type`\n\n- Hash の型を指定\n- `{ id: Integer, name: String }`\n\n---\n\n### `Interface type`\n\n例: each メソッドを持っている型\n\n```ruby\ninterface _Each[A, B]\n  def each: { (A) -\u003e void } -\u003e B\nend\n```\n\n---\n\n### `Literal type`\n\n- 型の取り得る値を限定できる\n- `1` という型は Integer かつ 値を `1` に限定\n- \"hello world\"という型や`:to_s`という型を定義可能\n\n---\n\n### `Union type`\n\n- 型の和を表わす\n- `Integer | String` は Integer or String\n\n---\n\n### `Intersection type`\n\n- 交差型\n- `Integer \u0026 String` は Integer and String\n- Hash の合成が主な用途？\n- `{ id: Integer } \u0026 { name: String }` は `{ id: Integer, name: String }`\n\n---\n\n### `Optional type`\n\n- みんな大好き null 安全\n- `Integer?` で `Integer | nil`\n\n---\n\n### ivar やメソッドの型定義\n\n- `@name: String` で ivar\n- `def to_s: () -\u003e String` でメソッドを定義\n\n---\n\n### 所見\n\n- TypeScript の影響が強い\n  - Literal type\n  - Intersection type\n- Interface type があればダックタイプもやりやすそう\n- 想像していたよりもリッチ\n- any じゃなくて untyped なのはわかりやすくていい\n\n---\n\n---\n\n## 実例を通して\n\nruby-signature はまだ StandardLibrary の片付けが終わっていないので\n適当なものに型をつけてみる\n\n---\n\n### Abbrev モジュール\n\n- StandardLibrary で最初に表示されている\n- module_function abbrev 一つだけのモジュールなので簡単\n- まだ ruby-signature で定義されていない\n\n---\n\n### Abbrev#abbrev とは\n\n`abbrev(words, pattern = nil)`\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=\u003e  {\"ruby\"=\u003e\"ruby\", \"rub\"=\u003e\"ruby\", \"ru\"=\u003e\"ruby\", \"r\"=\u003e\"ruby\"}\n\nAbbrev.abbrev(%w{ car cone })\n#=\u003e {\"ca\"=\u003e\"car\", \"con\"=\u003e\"cone\", \"co\"=\u003e\"cone\", \"car\"=\u003e\"car\", \"cone\"=\u003e\"cone\"}\n\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=\u003e {\"box\"=\u003e\"box\", \"bo\"=\u003e\"box\", \"b\"=\u003e\"box\", \"crab\" =\u003e \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=\u003e {\"car\"=\u003e\"car\", \"ca\"=\u003e\"car\"}\n```\n\nString の配列をうけとり、String を分解して key とし、元の String を value とする Hash を返す\n\n---\n\n### まずはシンプルなケース\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=\u003e  {\"ruby\"=\u003e\"ruby\", \"rub\"=\u003e\"ruby\", \"ru\"=\u003e\"ruby\", \"r\"=\u003e\"ruby\"}\n```\n\nこれに型を付けると\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String]) -\u003e Hash[String, String]\nend\n```\n\n`def self?` は module function 用の書き方\n空配列を受け取っても空ハッシュを返すだけなので問題なし。\n\n---\n\n### 第 2 引数について\n\nexample を見ると String と Regexp を受け取ることを想定しているよう\n\n```ruby\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=\u003e {\"box\"=\u003e\"box\", \"bo\"=\u003e\"box\", \"b\"=\u003e\"box\", \"crab\" =\u003e \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=\u003e {\"car\"=\u003e\"car\", \"ca\"=\u003e\"car\"}\n```\n\nじゃあ Integer とか渡したらエラーになるのかな？\n\n---\n\n### 想定していなさそうな型の引数を渡してみる\n\n```ruby\nAbbrev.abbrev(%w{12345}, 1)\n#=\u003e {}\n```\n\nエラーにならないだと…\nこの場合って型はどうつければいいのか。\n実装を abbrev の実装を見てみると\n\n---\n\n### abbrev の実装\n\n- String, Regexp 以外は `!~` を直接使っている\n- `Integer#!~` は常に true を返す\n\n```ruby\ndef abbrev(words, pattern = nil)\n  ...\n  if pattern.is_a?(String)\n    pattern = /\\A#{Regexp.quote(pattern)}/  # regard as a prefix\n  end\n```\n\n```ruby\n  words.each do |word|\n    next if word.empty?\n    word.size.downto(1) { |len|\n      abbrev = word[0...len]\n      next if pattern \u0026\u0026 pattern !~ abbrev\n      ...\n    }\n  end\nend\n```\n\n```ruby\n  words.each do |word|\n    next if pattern \u0026\u0026 pattern !~ word\n    table[word] = word\n  end\n  table\nend\n```\n\n---\n\n### abbrev の第 2 引数は String, Regexp 以外を考慮していない\n\n- String, Regexp 以外を考慮しておらず、たまたま `{}` を返すようになっているだけに見える\n- 実行時にエラーにならない場合はどう型をつければよいのか\n  - Integer or Object を引数に取ることを認める\n  - String と Regexp 以外は認めない\n\n---\n\n### このような場合にどうすればよいか\n\n- ドキュメントにどう書かれているか\n- エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n---\n\n### ドキュメント\n\n\u003e The optional pattern parameter is a pattern or a string.\n\u003e Only input strings that match the pattern or start with the string are included in the output hash.\n\npattern とは言っているけれど、それが Regexp とは限定していない。\n\n---\n\n### エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n何かのメソッドの返り値が String や Regexp だと思っていたのに Integer だった場合\n\n```ruby\ndef some_method: () -\u003e (String | Integer)\n\npattern = some_method()\n\nAbbrev.abbrev([\"12345\"], pattern)\n#=\u003e {}\n```\n\nInteger が来てここでエラーにならなくてもその後で不整合がおこる場合に困る。\nここを通るテストがない場合になぜ駄目なのかの調査が必要になる。\nそれよりも型検査で弾いてくれたほうが嬉しい。\n\n---\n\n### 結果\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String], ?(String | Regexp | nil)) -\u003e Hash[String, String]\nend\n\n```\n\n第 2 引数は String, Regexp, nil としました。\nこの定義で ruby-signature に PR を送ってマージされた。\n\n---\n\n## まとめ\n\n- ruby-signature の紹介\n- ドキュメントにない場合でもそれっぽく動く場合がある\n- どう動いてほしいかを考えて型をつけないといけない場合がある\n","slug":"feeling-to-type-ruby"},{"data":{"title":"Elm ことはじめ","published":"2019-10-28"},"content":"\n# `Elm` ことはじめ\n\n---\n\n## 自己紹介\n\n- wat-aro\n- 10%の時間では Elm でフロントエンドをやっていました\n- 関数型が好きです\n\n---\n\n## おしながき\n\n- Elm とは\n- 文法\n- TEA\n- まとめ\n\n---\n\n## Elm とは\n\n- 静的型付け Alt JS\n- A delightfull language\n- No Runtime Exception\n- Great Peerformance\n- Small Assets\n\n---\n\n### 静的型付けの Alt JS\n\nHaskell like な見た目\n\n```elm\nmap : (a -\u003e b) -\u003e List a -\u003e List b\nmap f list =\n  case list of\n    [] -\u003e []\n    (x :: xs) -\u003e f x :: (map f xs)\n```\n\n---\n\n### 静的型付けの Alt JS\n\n強力な型推論と親切なエラーメッセージ\n\n```elm\n\u003e 1 + \"1\"\n-- TYPE MISMATCH ----------------------------------------------------------- elm\n\nI cannot do addition with String values like this one:\n\n4|   1 + \"1\"\n         ^^^\nThe (+) operator only works with Int and Float values.\n\nHint: Switch to the (++) operator to append strings!\n```\n\n---\n\n### A delightful language\n\n公式サイトが言ってます\n\n[![Image from Gyazo](https://i.gyazo.com/772c9e8c416140a595a7ca586a66a159.png)](https://gyazo.com/772c9e8c416140a595a7ca586a66a159)\n\n---\n\n### Great Peerformance\n\n[![Image from Gyazo](https://i.gyazo.com/50ecbb1475d7b22a2495ebdc087d59af.png)](https://gyazo.com/50ecbb1475d7b22a2495ebdc087d59af)\n\n---\n\n### Small Assets\n\n[![Image from Gyazo](https://i.gyazo.com/7e580ab002610cd302a89046d9e28e0a.png)](https://gyazo.com/7e580ab002610cd302a89046d9e28e0a)\n\n---\n\n---\n\n## 文法\n\n- デフォルトカリー化\n- Haskell-like 型定義\n- パターンマッチ\n\n---\n\n### デフォルトカリー化\n\nML や Haskell のようにデフォルトでカリー化されている\n\n```elm\nadd : Int -\u003e Int -\u003e Int\nadd x y = x + y\n\nadd 2 3  -- 5\n\nadd2 : Int -\u003e Int\nadd2 = add 2\n\nadd2 3 -- 5\n```\n\n---\n\n### Haskell-like 型定義\n\n- Haskell like な型定義\n- 代数的データ型\n- 型クラスはない\n\n```elm\ntype Maybe a\n  = Just a\n  | Nothing\n```\n\n型アノテーションのコロンは一つ\n\n```elm\n42 : Int\n\"Hello Elm\" : String\n```\n\n---\n\n### パターンマッチ\n\n- 型定義に沿った形でパターンマッチができる\n- 網羅性検査もされるので漏れが出ない\n- 漏れているとコンパイルエラー\n\n```elm\ntype Maybe a\n  = Just a\n  | Nothing\n```\n\n```elm\nmap : (a -\u003e b) -\u003e Maybe a -\u003e Maybe b\nmap f x = case x of\n  Just a -\u003e Maybe (f a)\n  Nothing -\u003e Nothing\n\n```\n\n---\n\n---\n\n## The Elm Architecture(TEA)\n\n- `view`は`model`を受け取って`HTML`を作成する\n- `HTML`から`msg`を投げ、`update`が現在の`model`と`msg`から新しい`model`を作成する\n- 新しい`model`から再度`HTML`を作成する\n\n```elm\nsandbox :\n    { init : model\n    , view : model -\u003e Html msg\n    , update : msg -\u003e model -\u003e model\n    }\n    -\u003e Program () model msg\n```\n\n---\n\n### sandbox のライフサイクル\n\n![Browser.sandbox](https://guide.elm-lang.org/effects/diagrams/sandbox.svg)\n\n---\n\n### カヌンターアプリの例\n\n- `+` ボタンと `-` ボタンがあるカウンター\n- https://elm-lang.org/examples/buttons\n- モデルの初期値は 0\n- update と view はそれぞれの名前の関数\n\n```elm\nsandbox :\n    { init : model\n    , view : model -\u003e Html msg\n    , update : msg -\u003e model -\u003e model\n    }\n    -\u003e Program () model msg\n\nmain : Program () Int Msg\nmain =\n  Browser.sandbox { init = 0, update = update, view = view }\n```\n\n---\n\n### まずはメッセージの型定義から\n\n- Msg は Increment と Decrement の二つ\n- Increment が来たら model を +1 する\n- Decrement が来たら model を -1 する\n- RunTime System が update の返り値を受け取り現在のモデルを更新する\n\n```elm\ntype Msg = Increment | Decrement\n\nupdate : Msg -\u003e Int -\u003e Int\nupdate msg model =\n  case msg of\n    Increment -\u003e\n      model + 1\n\n    Decrement -\u003e\n      model - 1\n```\n\n---\n\n### 描画に使う関数\n\n- HTML タグ のタグも関数で定義されている\n- div の第一引数は Attribute msg のリスト\n- div の第二引数は Html msg のリスト\n- onClick の引数に msg を渡すと、クリックされた時にそのメッセージを投げる\n- text は文字列の描画用の関数\n- 型変数になっている部分は型推論で解決される\n\n```elm\ndiv : List (Attribute msg) -\u003e List (Html msg) -\u003e Html msg\nbutton : List (Attribute msg) -\u003e List (Html msg) -\u003e Html msg\nonClick : msg -\u003e Attribute msg\ntext : String -\u003e Html msg\n```\n\n---\n\n### 描画部分\n\n- さっきの関数を使って view を構成する\n\n```elm\nview : Int -\u003e Html Msg\nview model =\n  div []\n    [ button [ onClick Decrement ] [ text \"-\" ]\n    , div [] [ text (String.fromInt model) ]\n    , button [ onClick Increment ] [ text \"+\" ]\n    ]\n```\n\n---\n\n### 副作用を扱う例(Cat gifs)\n\n- 猫の GIF 画像をランダムに取得し描画するアプリ\n- https://elm-lang.org/examples/cat-gifs\n- `element` を使う\n\n---\n\n### Browser.element\n\n- `view`は変わらない\n- `update`の返り値が `model`から`(model, Cmd msg)`に変更\n- 外部からのイベントを扱う `subscriptions` が追加(今回は扱いません)\n\n```elm\nelement :\n    { init : flags -\u003e ( model, Cmd msg )\n    , view : model -\u003e Html msg\n    , update : msg -\u003e model -\u003e ( model, Cmd msg )\n    , subscriptions : model -\u003e Sub msg\n    }\n    -\u003e Program flags model msg\n```\n\n---\n\n### Cmd とは\n\n- 主に副作用を扱う(e.g. HTTP リクエスト, 乱数生成, 現在時の取得)\n- 実行した結果 `Cmd msg` を返し、その`msg`が `Runtime System` によって `update`に渡される\n\n---\n\n### 副作用を扱った場合のライフサイクル\n\n![Browser.element](https://guide.elm-lang.org/effects/diagrams/element.svg)\n\n---\n\n### Cat Gifs の Msg\n\n- 再度猫 Gif を取得する MorePlease\n- 猫 Gif の取得した結果を表す GotGif (Result Http.Error String)\n- Result error value 型は成功・失敗を表すことが出来る\n\n```elm\ntype Msg\n  = MorePlease\n  | GotGif (Result Http.Error String)\n```\n\n---\n\n### Cat Gif の Model\n\n- 猫画像取に失敗したら Failure\n- 取得中は Loading\n- 取得に成功したら Success に 猫 Gif の URL を文字列で持つ\n\n```elm\ntype Model\n  = Failure\n  | Loading\n  | Success String\n```\n\n---\n\n### Cat Gif の Initialize phase\n\n- モデルの初期値は Loading\n- getRandomCatGif で猫 Gif を取得する\n- Http.get の返り値の型が Cmd msg なので Cmd を強制される\n\n```elm\ninit : () -\u003e (Model, Cmd Msg)\ninit _ =\n  (Loading, getRandomCatGif)\n\nget : { url : String, expect : Expect msg } -\u003e Cmd msg\n\ngetRandomCatGif : Cmd Msg\ngetRandomCatGif =\n  Http.get\n    { url = \"https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC\u0026tag=cat\"\n    , expect = Http.expectJson GotGif gifDecoder\n    }\n```\n\n---\n\n### Cat Gif の更新 phase\n\n- MorePlease メッセージなら Loading 状態にして猫 Gif を取得しにいく\n- 取得した結果、成功していればモデルに URL を入れて描画、失敗していれば Failure 画面に\n\n```elm\nupdate : Msg -\u003e Model -\u003e (Model, Cmd Msg)\nupdate msg model =\n  case msg of\n    MorePlease -\u003e\n      (Loading, getRandomCatGif)\n\n    GotGif result -\u003e\n      case result of\n        Ok url -\u003e\n          (Success url, Cmd.none)\n\n        Err _ -\u003e\n          (Failure, Cmd.none)\n```\n\n---\n\n### Cat Gif の描画\n\n- view でもパターンマッチで状態を網羅して描画しているかが検査できる\n\n```elm\nview : Model -\u003e Html Msg\nview model =\n  div []\n    [ h2 [] [ text \"Random Cats\" ]\n    , viewGif model\n    ]\n\nviewGif : Model -\u003e Html Msg\nviewGif model =\n  case model of\n    Failure -\u003e\n      div []\n        [ text \"I could not load a random cat for some reason. \"\n        , button [ onClick MorePlease ] [ text \"Try Again!\" ]\n        ]\n\n    Loading -\u003e\n      text \"Loading...\"\n\n    Success url -\u003e\n      div []\n        [ button [ onClick MorePlease, style \"display\" \"block\" ] [ text \"More Please!\" ]\n        , img [ src url ] []\n        ]\n```\n\n---\n\n### TEA\n\n- 副作用を扱わない場合 model, update, message, view によって構成される\n- view から message を投げ、その message に合わせて model を更新する\n- 副作用を扱う場合は update から副作用(Cmd)を実行し、Cmd からまた message を投げ update で受け取る\n- 今回は見ていないけれど、外部からの入力(時間によって発するイベントや websocket のイベントなど\\*\\*は subscription で扱う\n\n---\n\n## まとめ\n\n- Elm の基本的なところを紹介しました\n- TEA を紹介しました\n- 簡潔な型定義とパターンマッチで安全にフロントエンドが開発できるよ！\n","slug":"getting-started-with-elm"},{"data":{"title":"パイプライン演算子","published":"2019-06-20"},"content":"\n## パイプライン演算子\n\nwat-aro\n\n---\n\n### パイプライン演算子\n\nこんな感じのやつ\n\n```elm\n  [1, 2, 3]\n  |\u003e List.map (\\x -\u003e x * 2)\n  |\u003e List.foldl (+)\n```\n\n---\n\n#### パイプライン演算子\n\n`|\u003e` の前の値を関数に適用する\n\n---\n\n#### パイプライン演算子\n\n- 元は Isabela/ML あたりが発祥\n- F# が採用\n- OCaml が採用\n- Elixir が F# から採用\n- Ruby に入りそう\n\n---\n\n---\n\n### ML などにおけるパイプライン演算子のつくりかた\n\n以下を満たせば簡単につくれる\n\n- ユーザ定義演算子\n- デフォルトでカリー化\n\n---\n\n#### Haskell でのつくり方\n\n第一引数を第二引数に適用するだけ\n\n```haskell\n(|\u003e) :: a -\u003e (a -\u003e b) -\u003e b\n(|\u003e) a f = f a\n```\n\n---\n\n---\n\n### カリー化と部分適用\n\n以降の話に関わるのでここでおさらい\n\n---\n\n#### カリー化\n\n複数の引数を受け取る関数を一引数の関数に変換する\n\n```haskell\nuncuffyFunction :: (a, b, c) -\u003e d\nuncuffyFunction (a, b, c) = somethingToDo a b c\n\ncurriedFunction :: a -\u003e b -\u003e c -\u003e d\ncurriedFunction a b c = somethingToDo a b c\n```\n\n---\n\n#### ES6\n\n```js\nconst uncurryFunction = (a, b, c) =\u003e somethigTodo(a, b, c);\n\nconst curriedFunction = (a) =\u003e (b) =\u003e (c) =\u003e somethingTodo(a, b, c);\n```\n\ncurriedFunction は引数を一つとると残りの引数を _一つずつ取る関数_ を返す\nuncurry な関数を curried な関数に変換するのが\n\n---\n\n### 部分適用\n\n複数の引数を取る関数で、一部にだけ引数を適用した状態の関数を返す。\n\n```js\nconst partialApplied = somethigTodo(1, 2, ?);\n```\n\n---\n\n### なぜカリー化と部分適用の話を？\n\nElixir などのデフォルトでカリー化されていない言語では関数のようにパイプライン演算子を定義できない\ne.g.\n\n- Elixir, Clojure はマクロ\n- Ruby は言語組み込みの機構\n\n---\n\n---\n\n### Elixir のパイプライン演算子\n\nML 系は関数の最後の引数に値を差し込む\nElixir は最初の引数を差し込む\n\n---\n\n#### Elixir の |\u003e\n\n```elixir\n[1, [[2], 3]]\n  |\u003e List.flatten\n  |\u003e Enum.map(fn x -\u003e x * x end)\n  |\u003e Enum.reduce(0, fn(x, acc) -\u003e x + acc end)\n```\n\n---\n\n#### Elixir の |\u003e\n\nカリー化されていないため AST を変換する必要がある\n\n---\n\n---\n\n### Ruby のパイプライン演算子\n\nパイプラインといいつつただの優先度の低い `.`\n\n---\n\n#### Ruby のパイプライン演算子\n\n```ruby\n(1..5).map {|x| x * 2 }\n\n1..5 |\u003e map {|x| x * 2 }\n```\n\nのように書ける\n\n---\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n[![Image from Gyazo](https://i.gyazo.com/4ecb8454c6bfc9d8470cb6c118129d21.png)](https://twitter.com/hanachin_/status/1139406434846695430)()\n\nこれの話をしたかった\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n```\n\n`.:` は Ruby 2.7 で入る演算子。\nMethod オブジェクトを取り出す。\nMethod オブジェクトはほぼ Proc オブジェクトと同じふるまい。\n詳しくはドキュメントを読んでください。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n```\n\n`URI.parse` でなく `URI.:parse` に注意。\nとりだした Method オブジェクトを `|\u003e` と `\u003e\u003e` で合成する。\n`\u003e\u003e` は Ruby2.6 で入った関数(Proc)合成演算子。\n`URI.:parse` で `URI.parse` の Method オブジェクトを取りだし、\n`\u003e\u003e` によって合成している。\nつまり\n\n```ruby\nURI.parse(\"https://api.github.com/repos/ruby/ruby \")\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n```\n\n`Net::HTTP.:get` で `Net:HTTP.get` の Method オブジェクトを取り出す。\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nNet::HTTP.get(uri)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n```\n\nここでも `JSON.:parse` で `JSON.parse` で Method オブジェクトを取り出す\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nresponse = Net::HTTP.get(uri)\nJSON.parse(response)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n```\n\n今までは Method オブジェクトを合成しただけなので、ここでやっと評価され、値になる。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n  |\u003e fetch(\"stargazers_count\")\n```\n\n`Hash#fetch` で値を取りだす\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n  |\u003e fetch(\"stargazers_count\")\n  |\u003e then { puts @1 }\n```\n\nそして標準出力へ。\n`@1` は Ruby2.7 で入る予定。\n\n```ruby\n\"hoge\".then { puts @1 }\n\"hoge\".then {|s| puts s }\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\nたーのしー\n\n---\n\n---\n\n### まとめ\n\nパイプライン演算子の説明\nRuby2.7 で入る予定のパイプライン演算子とその応用の紹介\n関数合成をキメていこう\n\n---\n\n#### 悲しみ\n\n[![Image from Gyazo](https://i.gyazo.com/47e87c4f7f7ad60bb2f657b4ebbf431b.png)](https://twitter.com/hanachin_/status/1139406434846695430)\n\n---\n\nもっと詳しく知りたい人は\n\n[パイプライン演算子の歴史 - まめめも](https://mametter.hatenablog.com/entry/2019/06/15/192311)\n[第一引数版パイプライン演算子 - Qiita @cedretaber](https://qiita.com/cedretaber/items/6a3831367439f64756ab)\n","slug":"pipeline-operator"}]},"__N_SSG":true},"page":"/posts","query":{},"buildId":"ylF5aIAZfEQnuFW-xnevL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>