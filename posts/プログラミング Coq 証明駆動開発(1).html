<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>プログラミング Coq 証明駆動開発(1) | (wat-aro)</title><meta name="title" content="プログラミング Coq 証明駆動開発(1) | (wat-aro)"/><meta name="description" content="&lt;p&gt;&lt;a href=&quot;http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html&quot;&gt;&amp;x8A3C;&amp;x660E;&amp;x99C6;&amp;x52D5;&amp;x958B;&amp;x767A;&amp;x5165;&amp;x9580;(1)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;何かを読む会&lt;/code&gt; という社内"/><meta property="og:locale" content="ja_jp"/><meta property="og:type" content="article"/><meta property="og:site_name" content="(wat-aro)"/><meta property="og:title" content="プログラミング Coq 証明駆動開発(1) | (wat-aro)"/><meta property="og:image" content="https://wat-aro.dev/og-images/プログラミング Coq 証明駆動開発(1).png"/><meta property="og:url" content="https://wat-aro.dev/posts/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%20Coq%20%E8%A8%BC%E6%98%8E%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA(1)"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@wat_aro"/><meta name="twitter:creator" content="@wat_aro"/><meta name="twitter:title" content="プログラミング Coq 証明駆動開発(1) | (wat-aro)"/><meta name="twitter:description" content="&lt;p&gt;&lt;a href=&quot;http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html&quot;&gt;&amp;x8A3C;&amp;x660E;&amp;x99C6;&amp;x52D5;&amp;x958B;&amp;x767A;&amp;x5165;&amp;x9580;(1)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;何かを読む会&lt;/code&gt; という社内"/><meta name="twitter:image" content="https://wat-aro.dev/og-images/プログラミング Coq 証明駆動開発(1).png"/><meta name="next-head-count" content="17"/><link rel="icon" href="/images/favicon.ico"/><link rel="preload" href="/_next/static/css/b967202bf5b2ddb4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b967202bf5b2ddb4.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-877c465da71eeb7d.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-847cc7a6659a518e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-5a221d7c4dbc914e.js" defer=""></script><script src="/_next/static/ECl7bP-8kgCOP0p99_NVN/_buildManifest.js" defer=""></script><script src="/_next/static/ECl7bP-8kgCOP0p99_NVN/_ssgManifest.js" defer=""></script><script src="/_next/static/ECl7bP-8kgCOP0p99_NVN/_middlewareManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MW6D56L" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="py-0 md:px-8 min-h-screen flex flex-col items-center"><div class="top-0 bg-white w-full h-16 flex flex-row justify-between items-center px-4 border-b-2"><a href="/"><div class="flex items-center font-midium text-3xl h-full font-bold gap-4"><img class="rounded-full" src="/images/profile.jpg" width="48" height="48" alt="profile image"/>(wat-aro)<!-- --></div></a><ul class="flex gap-3 h-full"><li class="h-full flex flex-col justify-end border-black pb-3 border-b-4"><a href="/posts">Blog</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/slides">Slide</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/about">About</a></li></ul></div><div class="flex md:justify-center justify-between w-full flex-grow"><div class="flex flex-col sm:max-w-sm md:max-w-4xl w-full py-4 px-4"><article class="flex max-w-4xl w-full"><div class="py-4 w-full"><div class="mr-2 text-xs font-bold">2017/05/11</div><h1 class="font-bold text-3xl text-black">プログラミング Coq 証明駆動開発(1)</h1><nav class="flex mt-2 mb-2 items-start text-gray-500 text-xs"><div class="flex flex-wrap max-w-full overflow-x-auto gap-2"></div></nav><div class="znc"><p><a href="http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html">証明駆動開発入門(1)</a></p>
<p><code>何かを読む会</code> という社内勉強会が発足されました。
読んだ本の内容を共有しよう。
一人で勉強していてもダレるので共有することで無理やり進捗を出そう。
他の人の発表を聞いて読んだ気になろう。
っていう緩めの会です。
途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。</p>
<h1 id="挿入ソートを証明する">挿入ソートを証明する。</h1>
<p>証明したいことは次の二点。</p>
<ul>
<li>挿入前と挿入後で要素に変化がないこと(isort_permutation)</li>
<li>挿入後に要素が整列されていること(isort_sorted)</li>
</ul>
<p>上記を型で示すと以下のようになる。</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">isort_permutation : forall (l : list nat), Permutation l (insertion_sort l)
</span><span class="code-line">isort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)</span></code></pre>
<h2 id="実装">実装</h2>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Require Import List.
</span><span class="code-line">Require Import Arith.
</span><span class="code-line">
</span><span class="code-line">Fixpoint insert (a : nat) (l : list nat) : list nat :=
</span><span class="code-line">  match l with
</span><span class="code-line">  | nil => a :: nil
</span><span class="code-line">  | x :: xs => if leb a x then a :: l else x :: insert a xs
</span><span class="code-line">  end.
</span><span class="code-line">
</span><span class="code-line">Fixpoint insertion_sort (l : list nat) : list nat :=
</span><span class="code-line">  match l with
</span><span class="code-line">  | nil => nil
</span><span class="code-line">  | x :: xs => insert x (insertion_sort xs)
</span><span class="code-line">  end.</span></code></pre>
<h2 id="要素の変化がないこと">要素の変化がないこと</h2>
<p>あるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Inductive Permutation : list A -> list A -> Prop :=
</span><span class="code-line">  | perm_nil: Permutation [] []
</span><span class="code-line">  | perm_skip x l l' : Permutation l l' -> Permutation (x::l) (x::l')
</span><span class="code-line">  | perm_swap x y l : Permutation (y::x::l) (x::y::l)
</span><span class="code-line">  | perm_trans l l' l'' : Permutation l l' -> Permutation l' l'' -> Permutation l l''.</span></code></pre>
<ol>
<li><a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> と <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> は同じ要素から成り立つ</li>
<li>l と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ</li>
<li>y :: x :: l と x :: y :: l は同じ要素から成り立つ</li>
<li>(l と l' が同じ要素から成り立ち、l' と l'‘ が同じ要素から成り立つ) ならば l と l’‘ も同じ要素から成り立つ</li>
</ol>
<h2 id="isort_permutation-の証明">isort_permutation の証明</h2>
<p>isort_permutation の型</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : list nat), Permutation l (insertion_sort l)</span></code></pre>
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1">帰納法</a>を使う。
l が <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> の時は insertion_sort l は <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> なので
Permutation <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> となり自明。</p>
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1">帰納法</a>のため、nの場合にあたる仮定は</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : list nat), Permutation xs (insertion_sort xs)</span></code></pre>
<p>n + 1 に当たる命題は</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : list nat), Permutation x :: xs (insertion_sort x::xs)</span></code></pre>
<p>となり、</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)</span></code></pre>
<p>と変形できる。</p>
<p>つまり</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)</span></code></pre>
<p>と</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)</span></code></pre>
<p>を示すことで perm_trans から</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">forall l l' l'' , Permutation l l' -> Permutation l' l'' -> Permutation l l''</span></code></pre>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Permutation (x :: xs) (x :: insertion_sort xs) ->
</span><span class="code-line">  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) ->
</span><span class="code-line">    Permutation (x :: xs) (insert x (insertion_sort xs))</span></code></pre>
<p>となり、導ける。</p>
<p>A  については 仮定と Permutation のコンストラクタ</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">perm_skip : forall x l l', Permutation l l' -> Permutation (x :: l) (x :: l')</span></code></pre>
<p>から導ける。</p>
<p>まず B を<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA">補題</a>として証明する。</p>
<p>isort_permutaiton の証明は以下。</p>
<table>
<thead>
<tr>
<th> 命令 </th>
<th> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td> intros </td>
<td> forall などから変数を仮定へ移動する </td>
</tr>
<tr>
<td> simpl </td>
<td> 簡約 </td>
</tr>
<tr>
<td> apply </td>
<td> 仮定や定理などを適用 </td>
</tr>
<tr>
<td> destruct </td>
<td> 条件分岐しているものなどを subgoal に分ける </td>
</tr>
<tr>
<td> induction </td>
<td> <a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1">帰納法</a>を実施するために subgoal に分ける </td>
</tr>
</tbody>
</table>
<p>どういうふうに証明が進むかは coq <a class="keyword" href="http://d.hatena.ne.jp/keyword/ide">ide</a> や proof-general 使って見てください。</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Require Import List.
</span><span class="code-line">Require Import Arith.
</span><span class="code-line">Require Import Sorting.Permutation.
</span><span class="code-line">Require Import Sorting.Sorted.
</span><span class="code-line">
</span><span class="code-line">(* isort_permutation *)
</span><span class="code-line">
</span><span class="code-line">Lemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).
</span><span class="code-line">  induction l.
</span><span class="code-line">  intros.
</span><span class="code-line">  simpl.
</span><span class="code-line">  apply Permutation_refl.
</span><span class="code-line">
</span><span class="code-line">  intros.
</span><span class="code-line">  simpl.
</span><span class="code-line">  destruct (leb x a).
</span><span class="code-line">
</span><span class="code-line">  apply Permutation_refl.
</span><span class="code-line">
</span><span class="code-line">  apply perm_trans with (a :: x :: l).
</span><span class="code-line">  apply perm_swap.
</span><span class="code-line">
</span><span class="code-line">  apply perm_skip.
</span><span class="code-line">  apply IHl.
</span><span class="code-line">Qed.
</span><span class="code-line">
</span><span class="code-line">Theorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).
</span><span class="code-line">  induction l.
</span><span class="code-line">  apply perm_nil.
</span><span class="code-line">  simpl.
</span><span class="code-line">  apply perm_trans with (a :: insertion_sort l).
</span><span class="code-line">  apply perm_skip.
</span><span class="code-line">  apply IHl.
</span><span class="code-line">  apply insert_perm.
</span><span class="code-line">Qed.</span></code></pre>
<h2 id="整列の定義">整列の定義</h2>
<p>リスト l が整列されていることはSorting.Sortedモジュールで定義されている.</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Induction LocallySorted (A : Type) (R : A -> A -> Prop) : list A :=
</span><span class="code-line">  | LSorted_nil : LocallySorted R nil
</span><span class="code-line">  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)
</span><span class="code-line">  | LSorted_consn : forall (a b : A) (l : list A),
</span><span class="code-line">    LocallySorted R (b :: l) ->
</span><span class="code-line">      R a b -> LocallySorted R (a :: b :: l)</span></code></pre>
<p>上の定義は次のような意味です。
R a b は a &#x3C; b のようなものです。</p>
<ol>
<li><a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> は整列している</li>
<li>x :: <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> は整列している</li>
<li>b :: l が整列しているとき, R a b ならば a :: b :: l は整列している</li>
</ol>
<h2 id="整列されていることの証明">整列されていることの証明</h2>
<p>こちらでも<a class="keyword" href="http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1">帰納法</a>で考える。
まず l が <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> の場合は insertion_sort <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> = <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> となり、LSorted_<a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> : LocallySorted le <a class="keyword" href="http://d.hatena.ne.jp/keyword/nil">nil</a> から明らか。</p>
<p>LocallySort le (insertion_sort l) -> LocallySort le (insertion_sort (a :: l)) の場合を考える。
LocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。
この時、insertion_sort l は仮定より整列しているため、</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">insert_sorted : forall (a : nat) (l : list a), LocallySort le l -> LocallySorted le (insert a l)</span></code></pre>
<p>を示すことができれば証明できる。</p>
<p>これを<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA">補題</a>として証明をすすめる。</p>
<h2 id="整列の証明">整列の証明</h2>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Lemma insert_sorted : forall (a : nat) (l : list nat),
</span><span class="code-line">    LocallySorted le l -> LocallySorted le (insert a l).
</span><span class="code-line">  induction l.
</span><span class="code-line">  constructor.
</span><span class="code-line">
</span><span class="code-line">  intro.
</span><span class="code-line">  simpl.
</span><span class="code-line">  remember (leb a a0).
</span><span class="code-line">  destruct b.
</span><span class="code-line">
</span><span class="code-line">  apply LSorted_consn.
</span><span class="code-line">  apply H.
</span><span class="code-line">  apply leb_complete.
</span><span class="code-line">  congruence.
</span><span class="code-line">
</span><span class="code-line">  inversion H.
</span><span class="code-line">  simpl.
</span><span class="code-line">  apply LSorted_consn.
</span><span class="code-line">  apply LSorted_cons1.
</span><span class="code-line">  apply lt_le_weak.
</span><span class="code-line">  apply leb_complete_conv.
</span><span class="code-line">  congruence.
</span><span class="code-line">
</span><span class="code-line">  subst.
</span><span class="code-line">  simpl.
</span><span class="code-line">  simpl in IHl.
</span><span class="code-line">  remember (leb a b).
</span><span class="code-line">
</span><span class="code-line">  destruct b0.
</span><span class="code-line">  apply LSorted_consn.
</span><span class="code-line">  apply IHl.
</span><span class="code-line">  apply H2.
</span><span class="code-line">
</span><span class="code-line">  apply lt_le_weak.
</span><span class="code-line">  apply leb_complete_conv.
</span><span class="code-line">  congruence.
</span><span class="code-line">
</span><span class="code-line">  apply LSorted_consn.
</span><span class="code-line">  apply IHl.
</span><span class="code-line">  apply H2.
</span><span class="code-line">  apply H3.
</span><span class="code-line">Qed.</span></code></pre>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Theorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).
</span><span class="code-line">  induction l.
</span><span class="code-line">  constructor.
</span><span class="code-line">
</span><span class="code-line">  simpl.
</span><span class="code-line">
</span><span class="code-line">  apply insert_sorted.
</span><span class="code-line">  apply IHl.
</span><span class="code-line">Qed.</span></code></pre>
<p>これで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。</p></div></div></article></div></div><div class="flex md:justify-center w-full"><div class="flex flex-col md:max-w-4xl w-full"><hr/><div class="flex justify-center pt-4 pb-8">© 2022 wat-aro</div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"プログラミング Coq 証明駆動開発(1)","published":"2017/05/11","tags":[],"content":"\n\u003cp\u003e\u003ca href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html\"\u003e\u0026#x8A3C;\u0026#x660E;\u0026#x99C6;\u0026#x52D5;\u0026#x958B;\u0026#x767A;\u0026#x5165;\u0026#x9580;(1)\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e何かを読む会\u003c/code\u003e という社内勉強会が発足されました。\n読んだ本の内容を共有しよう。\n一人で勉強していてもダレるので共有することで無理やり進捗を出そう。\n他の人の発表を聞いて読んだ気になろう。\nっていう緩めの会です。\n途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。\u003c/p\u003e\n\n\u003ch1\u003e挿入ソートを証明する。\u003c/h1\u003e\n\n\u003cp\u003e証明したいことは次の二点。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e挿入前と挿入後で要素に変化がないこと(isort_permutation)\u003c/li\u003e\n\u003cli\u003e挿入後に要素が整列されていること(isort_sorted)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003cp\u003e上記を型で示すと以下のようになる。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eisort_permutation : forall (l : list nat), Permutation l (insertion_sort l)\nisort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)\u003c/pre\u003e\n\n\n\u003ch2\u003e実装\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eRequire Import List.\nRequire Import Arith.\n\nFixpoint insert (a : nat) (l : list nat) : list nat :=\n  match l with\n  | nil =\u0026gt; a :: nil\n  | x :: xs =\u0026gt; if leb a x then a :: l else x :: insert a xs\n  end.\n\nFixpoint insertion_sort (l : list nat) : list nat :=\n  match l with\n  | nil =\u0026gt; nil\n  | x :: xs =\u0026gt; insert x (insertion_sort xs)\n  end.\u003c/pre\u003e\n\n\n\u003ch2\u003e要素の変化がないこと\u003c/h2\u003e\n\n\u003cp\u003eあるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eInductive Permutation : list A -\u0026gt; list A -\u0026gt; Prop :=\n  | perm_nil: Permutation [] []\n  | perm_skip x l l\u0026#39; : Permutation l l\u0026#39; -\u0026gt; Permutation (x::l) (x::l\u0026#39;)\n  | perm_swap x y l : Permutation (y::x::l) (x::y::l)\n  | perm_trans l l\u0026#39; l\u0026#39;\u0026#39; : Permutation l l\u0026#39; -\u0026gt; Permutation l\u0026#39; l\u0026#39;\u0026#39; -\u0026gt; Permutation l l\u0026#39;\u0026#39;.\u003c/pre\u003e\n\n\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003el と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003ey :: x :: l と x :: y :: l は同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003e(l と l' が同じ要素から成り立ち、l' と l'\u0026lsquo; が同じ要素から成り立つ) ならば l と l\u0026rsquo;\u0026lsquo; も同じ要素から成り立つ\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003ch2\u003eisort_permutation の証明\u003c/h2\u003e\n\n\u003cp\u003eisort_permutation の型\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : list nat), Permutation l (insertion_sort l)\u003c/pre\u003e\n\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eを使う。\nl が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e の時は insertion_sort l は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e なので\nPermutation \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e となり自明。\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eのため、nの場合にあたる仮定は\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : list nat), Permutation xs (insertion_sort xs)\u003c/pre\u003e\n\n\n\u003cp\u003en + 1 に当たる命題は\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : list nat), Permutation x :: xs (insertion_sort x::xs)\u003c/pre\u003e\n\n\n\u003cp\u003eとなり、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)\u003c/pre\u003e\n\n\n\u003cp\u003eと変形できる。\u003c/p\u003e\n\n\u003cp\u003eつまり\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)\u003c/pre\u003e\n\n\n\u003cp\u003eと\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)\u003c/pre\u003e\n\n\n\u003cp\u003eを示すことで perm_trans から\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eforall l l\u0026#39; l\u0026#39;\u0026#39; , Permutation l l\u0026#39; -\u0026gt; Permutation l\u0026#39; l\u0026#39;\u0026#39; -\u0026gt; Permutation l l\u0026#39;\u0026#39;\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003ePermutation (x :: xs) (x :: insertion_sort xs) -\u0026gt;\n  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) -\u0026gt;\n    Permutation (x :: xs) (insert x (insertion_sort xs))\u003c/pre\u003e\n\n\n\u003cp\u003eとなり、導ける。\u003c/p\u003e\n\n\u003cp\u003eA  については 仮定と Permutation のコンストラクタ\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eperm_skip : forall x l l\u0026#39;, Permutation l l\u0026#39; -\u0026gt; Permutation (x :: l) (x :: l\u0026#39;)\u003c/pre\u003e\n\n\n\u003cp\u003eから導ける。\u003c/p\u003e\n\n\u003cp\u003eまず B を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\"\u003e補題\u003c/a\u003eとして証明する。\u003c/p\u003e\n\n\u003cp\u003eisort_permutaiton の証明は以下。\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e 命令 \u003c/th\u003e\n\u003cth\u003e 説明 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e intros \u003c/td\u003e\n\u003ctd\u003e forall などから変数を仮定へ移動する \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e simpl \u003c/td\u003e\n\u003ctd\u003e 簡約 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e apply \u003c/td\u003e\n\u003ctd\u003e 仮定や定理などを適用 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e destruct \u003c/td\u003e\n\u003ctd\u003e 条件分岐しているものなどを subgoal に分ける \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e induction \u003c/td\u003e\n\u003ctd\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eを実施するために subgoal に分ける \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\n\u003cp\u003eどういうふうに証明が進むかは coq \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\"\u003eide\u003c/a\u003e や proof-general 使って見てください。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eRequire Import List.\nRequire Import Arith.\nRequire Import Sorting.Permutation.\nRequire Import Sorting.Sorted.\n\n(* isort_permutation *)\n\nLemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).\n  induction l.\n  intros.\n  simpl.\n  apply Permutation_refl.\n\n  intros.\n  simpl.\n  destruct (leb x a).\n\n  apply Permutation_refl.\n\n  apply perm_trans with (a :: x :: l).\n  apply perm_swap.\n\n  apply perm_skip.\n  apply IHl.\nQed.\n\nTheorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).\n  induction l.\n  apply perm_nil.\n  simpl.\n  apply perm_trans with (a :: insertion_sort l).\n  apply perm_skip.\n  apply IHl.\n  apply insert_perm.\nQed.\u003c/pre\u003e\n\n\n\u003ch2\u003e整列の定義\u003c/h2\u003e\n\n\u003cp\u003eリスト l が整列されていることはSorting.Sortedモジュールで定義されている.\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eInduction LocallySorted (A : Type) (R : A -\u0026gt; A -\u0026gt; Prop) : list A :=\n  | LSorted_nil : LocallySorted R nil\n  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)\n  | LSorted_consn : forall (a b : A) (l : list A),\n    LocallySorted R (b :: l) -\u0026gt;\n      R a b -\u0026gt; LocallySorted R (a :: b :: l)\u003c/pre\u003e\n\n\n\u003cp\u003e上の定義は次のような意味です。\nR a b は a \u0026lt; b のようなものです。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は整列している\u003c/li\u003e\n\u003cli\u003ex :: \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は整列している\u003c/li\u003e\n\u003cli\u003eb :: l が整列しているとき, R a b ならば a :: b :: l は整列している\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003ch2\u003e整列されていることの証明\u003c/h2\u003e\n\n\u003cp\u003eこちらでも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eで考える。\nまず l が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e の場合は insertion_sort \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e = \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e となり、LSorted_\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e : LocallySorted le \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e から明らか。\u003c/p\u003e\n\n\u003cp\u003eLocallySort le (insertion_sort l) -\u003e LocallySort le (insertion_sort (a :: l)) の場合を考える。\nLocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。\nこの時、insertion_sort l は仮定より整列しているため、\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003einsert_sorted : forall (a : nat) (l : list a), LocallySort le l -\u0026gt; LocallySorted le (insert a l)\u003c/pre\u003e\n\n\n\u003cp\u003eを示すことができれば証明できる。\u003c/p\u003e\n\n\u003cp\u003eこれを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\"\u003e補題\u003c/a\u003eとして証明をすすめる。\u003c/p\u003e\n\n\u003ch2\u003e整列の証明\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eLemma insert_sorted : forall (a : nat) (l : list nat),\n    LocallySorted le l -\u0026gt; LocallySorted le (insert a l).\n  induction l.\n  constructor.\n\n  intro.\n  simpl.\n  remember (leb a a0).\n  destruct b.\n\n  apply LSorted_consn.\n  apply H.\n  apply leb_complete.\n  congruence.\n\n  inversion H.\n  simpl.\n  apply LSorted_consn.\n  apply LSorted_cons1.\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  subst.\n  simpl.\n  simpl in IHl.\n  remember (leb a b).\n\n  destruct b0.\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n  apply H3.\nQed.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eTheorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).\n  induction l.\n  constructor.\n\n  simpl.\n\n  apply insert_sorted.\n  apply IHl.\nQed.\u003c/pre\u003e\n\n\n\u003cp\u003eこれで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。\u003c/p\u003e\n\n","slug":"プログラミング Coq 証明駆動開発(1)"},"content":"\u003cp\u003e\u003ca href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html\"\u003e証明駆動開発入門(1)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e何かを読む会\u003c/code\u003e という社内勉強会が発足されました。\n読んだ本の内容を共有しよう。\n一人で勉強していてもダレるので共有することで無理やり進捗を出そう。\n他の人の発表を聞いて読んだ気になろう。\nっていう緩めの会です。\n途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。\u003c/p\u003e\n\u003ch1 id=\"挿入ソートを証明する\"\u003e挿入ソートを証明する。\u003c/h1\u003e\n\u003cp\u003e証明したいことは次の二点。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e挿入前と挿入後で要素に変化がないこと(isort_permutation)\u003c/li\u003e\n\u003cli\u003e挿入後に要素が整列されていること(isort_sorted)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上記を型で示すと以下のようになる。\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eisort_permutation : forall (l : list nat), Permutation l (insertion_sort l)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eisort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"実装\"\u003e実装\u003c/h2\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eRequire Import List.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eRequire Import Arith.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eFixpoint insert (a : nat) (l : list nat) : list nat :=\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  match l with\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | nil =\u003e a :: nil\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | x :: xs =\u003e if leb a x then a :: l else x :: insert a xs\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  end.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eFixpoint insertion_sort (l : list nat) : list nat :=\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  match l with\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | nil =\u003e nil\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | x :: xs =\u003e insert x (insertion_sort xs)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  end.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"要素の変化がないこと\"\u003e要素の変化がないこと\u003c/h2\u003e\n\u003cp\u003eあるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eInductive Permutation : list A -\u003e list A -\u003e Prop :=\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | perm_nil: Permutation [] []\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | perm_skip x l l' : Permutation l l' -\u003e Permutation (x::l) (x::l')\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | perm_swap x y l : Permutation (y::x::l) (x::y::l)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | perm_trans l l' l'' : Permutation l l' -\u003e Permutation l' l'' -\u003e Permutation l l''.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e と \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003el と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003ey :: x :: l と x :: y :: l は同じ要素から成り立つ\u003c/li\u003e\n\u003cli\u003e(l と l' が同じ要素から成り立ち、l' と l'‘ が同じ要素から成り立つ) ならば l と l’‘ も同じ要素から成り立つ\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"isort_permutation-の証明\"\u003eisort_permutation の証明\u003c/h2\u003e\n\u003cp\u003eisort_permutation の型\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : list nat), Permutation l (insertion_sort l)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eを使う。\nl が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e の時は insertion_sort l は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e なので\nPermutation \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e となり自明。\u003c/p\u003e\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eのため、nの場合にあたる仮定は\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : list nat), Permutation xs (insertion_sort xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003en + 1 に当たる命題は\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : list nat), Permutation x :: xs (insertion_sort x::xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eとなり、\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと変形できる。\u003c/p\u003e\n\u003cp\u003eつまり\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eを示すことで perm_trans から\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eforall l l' l'' , Permutation l l' -\u003e Permutation l' l'' -\u003e Permutation l l''\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003ePermutation (x :: xs) (x :: insertion_sort xs) -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e    Permutation (x :: xs) (insert x (insertion_sort xs))\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eとなり、導ける。\u003c/p\u003e\n\u003cp\u003eA  については 仮定と Permutation のコンストラクタ\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eperm_skip : forall x l l', Permutation l l' -\u003e Permutation (x :: l) (x :: l')\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eから導ける。\u003c/p\u003e\n\u003cp\u003eまず B を\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\"\u003e補題\u003c/a\u003eとして証明する。\u003c/p\u003e\n\u003cp\u003eisort_permutaiton の証明は以下。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e 命令 \u003c/th\u003e\n\u003cth\u003e 説明 \u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e intros \u003c/td\u003e\n\u003ctd\u003e forall などから変数を仮定へ移動する \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e simpl \u003c/td\u003e\n\u003ctd\u003e 簡約 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e apply \u003c/td\u003e\n\u003ctd\u003e 仮定や定理などを適用 \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e destruct \u003c/td\u003e\n\u003ctd\u003e 条件分岐しているものなどを subgoal に分ける \u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e induction \u003c/td\u003e\n\u003ctd\u003e \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eを実施するために subgoal に分ける \u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eどういうふうに証明が進むかは coq \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\"\u003eide\u003c/a\u003e や proof-general 使って見てください。\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eRequire Import List.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eRequire Import Arith.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eRequire Import Sorting.Permutation.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eRequire Import Sorting.Sorted.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e(* isort_permutation *)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eLemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  induction l.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  intros.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply Permutation_refl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  intros.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  destruct (leb x a).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply Permutation_refl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_trans with (a :: x :: l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_swap.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_skip.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eQed.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eTheorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  induction l.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_nil.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_trans with (a :: insertion_sort l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply perm_skip.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply insert_perm.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eQed.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"整列の定義\"\u003e整列の定義\u003c/h2\u003e\n\u003cp\u003eリスト l が整列されていることはSorting.Sortedモジュールで定義されている.\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eInduction LocallySorted (A : Type) (R : A -\u003e A -\u003e Prop) : list A :=\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | LSorted_nil : LocallySorted R nil\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  | LSorted_consn : forall (a b : A) (l : list A),\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e    LocallySorted R (b :: l) -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      R a b -\u003e LocallySorted R (a :: b :: l)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上の定義は次のような意味です。\nR a b は a \u0026#x3C; b のようなものです。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は整列している\u003c/li\u003e\n\u003cli\u003ex :: \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e は整列している\u003c/li\u003e\n\u003cli\u003eb :: l が整列しているとき, R a b ならば a :: b :: l は整列している\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"整列されていることの証明\"\u003e整列されていることの証明\u003c/h2\u003e\n\u003cp\u003eこちらでも\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\"\u003e帰納法\u003c/a\u003eで考える。\nまず l が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e の場合は insertion_sort \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e = \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e となり、LSorted_\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e : LocallySorted le \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\"\u003enil\u003c/a\u003e から明らか。\u003c/p\u003e\n\u003cp\u003eLocallySort le (insertion_sort l) -\u003e LocallySort le (insertion_sort (a :: l)) の場合を考える。\nLocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。\nこの時、insertion_sort l は仮定より整列しているため、\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003einsert_sorted : forall (a : nat) (l : list a), LocallySort le l -\u003e LocallySorted le (insert a l)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eを示すことができれば証明できる。\u003c/p\u003e\n\u003cp\u003eこれを\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\"\u003e補題\u003c/a\u003eとして証明をすすめる。\u003c/p\u003e\n\u003ch2 id=\"整列の証明\"\u003e整列の証明\u003c/h2\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eLemma insert_sorted : forall (a : nat) (l : list nat),\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e    LocallySorted le l -\u003e LocallySorted le (insert a l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  induction l.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  constructor.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  intro.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  remember (leb a a0).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  destruct b.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply LSorted_consn.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply H.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply leb_complete.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  congruence.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  inversion H.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply LSorted_consn.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply LSorted_cons1.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply lt_le_weak.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply leb_complete_conv.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  congruence.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  subst.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl in IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  remember (leb a b).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  destruct b0.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply LSorted_consn.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply H2.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply lt_le_weak.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply leb_complete_conv.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  congruence.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply LSorted_consn.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply H2.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply H3.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eQed.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eTheorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  induction l.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  constructor.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  simpl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply insert_sorted.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  apply IHl.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eQed.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこれで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。\u003c/p\u003e"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"プログラミング Coq 証明駆動開発(1)"},"buildId":"ECl7bP-8kgCOP0p99_NVN","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>