<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>プログラミング Coq (証明駆動開発 2) | (wat-aro)</title><meta name="title" content="プログラミング Coq (証明駆動開発 2) | (wat-aro)"/><meta name="description" content="&lt;p&gt;&lt;a href=&quot;http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html&quot;&gt;&amp;x8A3C;&amp;x660E;&amp;x99C6;&amp;x52D5;&amp;x958B;&amp;x767A;&amp;x5165;&amp;x9580;(2)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上記ページの勉強メモです。&lt;/p&gt;&lt;h1&gt;Extr"/><meta property="og:locale" content="ja_jp"/><meta property="og:type" content="article"/><meta property="og:site_name" content="(wat-aro)"/><meta property="og:title" content="プログラミング Coq (証明駆動開発 2) | (wat-aro)"/><meta property="og:image" content="https://wat-aro.dev/og-images/プログラミング Coq (証明駆動開発 2).png"/><meta property="og:url" content="https://wat-aro.dev/posts/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%20Coq%20(%E8%A8%BC%E6%98%8E%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA%202)"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@wat_aro"/><meta name="twitter:creator" content="@wat_aro"/><meta name="twitter:title" content="プログラミング Coq (証明駆動開発 2) | (wat-aro)"/><meta name="twitter:description" content="&lt;p&gt;&lt;a href=&quot;http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html&quot;&gt;&amp;x8A3C;&amp;x660E;&amp;x99C6;&amp;x52D5;&amp;x958B;&amp;x767A;&amp;x5165;&amp;x9580;(2)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上記ページの勉強メモです。&lt;/p&gt;&lt;h1&gt;Extr"/><meta name="twitter:image" content="https://wat-aro.dev/og-images/プログラミング Coq (証明駆動開発 2).png"/><meta name="next-head-count" content="17"/><link rel="icon" href="/images/favicon.ico"/><link rel="preload" href="/_next/static/css/cef7709dba1aabcc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cef7709dba1aabcc.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-e7be5a2ce3007f17.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-847cc7a6659a518e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-5a221d7c4dbc914e.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_buildManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_ssgManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_middlewareManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MW6D56L" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="py-0 md:px-8 min-h-screen flex flex-col items-center"><div class="top-0 bg-white w-full h-16 flex flex-row justify-between items-center px-4 border-b-2"><a href="/"><div class="flex items-center font-midium text-3xl h-full font-bold gap-4"><img class="rounded-full" src="/images/profile.jpg" width="48" height="48" alt="profile image"/>(wat-aro)<!-- --></div></a><ul class="flex gap-3 h-full"><li class="h-full flex flex-col justify-end border-black pb-3 border-b-4"><a href="/posts">Blog</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/slides">Slide</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/about">About</a></li></ul></div><div class="flex md:justify-center justify-between w-full flex-grow"><div class="flex flex-col sm:max-w-sm md:max-w-4xl w-full py-4 px-4"><article class="flex max-w-4xl w-full"><div class="py-4 w-full"><div class="mr-2 text-xs font-bold">2017/05/11</div><h1 class="font-bold text-3xl text-black">プログラミング Coq (証明駆動開発 2)</h1><nav class="flex mt-2 mb-2 items-start text-gray-500 text-xs"><div class="flex flex-wrap max-w-full overflow-x-auto gap-2"></div></nav><div class="znc"><p><a href="http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html">証明駆動開発入門(2)</a></p>
<p>上記ページの勉強メモです。</p>
<h1 id="extraction">Extraction</h1>
<p>coq から <a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>, <a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>, <a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a> のコードを出力する。<br></p>
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> にコードを出力するにはそのまま<br></p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction map.</span></code></pre>
<p>とすればいい。<br>
これで</p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink=""><code class="code-highlight"><span class="code-line"><span class="synComment">(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synStatement">let</span> <span class="synStatement">rec</span> map f <span class="synStatement">=</span> <span class="synStatement">function</span>
</span><span class="code-line"><span class="synStatement">|</span> <span class="synConstant">Nil</span> <span class="synStatement">-></span> <span class="synConstant">Nil</span>
</span><span class="code-line"><span class="synStatement">|</span> <span class="synConstant">Cons</span> <span class="synStatement">(</span>a, t<span class="synStatement">)</span> <span class="synStatement">-></span> <span class="synConstant">Cons</span> <span class="synStatement">((</span>f a<span class="synStatement">)</span>, <span class="synStatement">(</span>map f t<span class="synStatement">))</span>
</span></code></pre>
<p>と出力される。（proof-general を使っています。coq-<a class="keyword" href="http://d.hatena.ne.jp/keyword/ide">ide</a>の場合はcommand pane で実行）<br></p>
<p>この時、list が <a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> 組み込みのリストでなく coq で定義された list になっている。<br>
<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> 組み込みのリストを使うには<br></p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extract Inductive list => "list" ["[]" "(::)"].</span></code></pre>
<p>を実行する。こうすると<br></p>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink=""><code class="code-highlight"><span class="code-line"><span class="synComment">(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synStatement">let</span> <span class="synStatement">rec</span> map f <span class="synStatement">=</span> <span class="synStatement">function</span>
</span><span class="code-line"><span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-></span> <span class="synConstant">[]</span>
</span><span class="code-line"><span class="synStatement">|</span> a<span class="synStatement">::</span>t <span class="synStatement">-></span> <span class="synStatement">(</span>f a<span class="synStatement">)::(</span>map f t<span class="synStatement">)</span>
</span></code></pre>
<p>と<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> 組み込みのリストを使ったmap関数が生成される。<br></p>
<p><a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>  や <a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a> に出力するにはそれぞれ<br>
<code>Extraction Language Haskell.</code> <code>Extraction Language Scheme.</code> としてから<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>の場合と同じように出力する。<br></p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Haskell.
</span><span class="code-line">Extract Inductive list => "list" ["[]" "(::)"].
</span><span class="code-line">Extraction map.</span></code></pre>
<pre class="code lang-haskell" data-lang="haskell" data-unlink=""><code class="code-highlight"><span class="code-line">map <span class="synStatement">::</span> (a1 <span class="synStatement">-></span> a2) <span class="synStatement">-></span> (list a1) <span class="synStatement">-></span> list a2
</span><span class="code-line">map f l <span class="synStatement">=</span>
</span><span class="code-line">  <span class="synStatement">case</span> l <span class="synStatement">of</span> {
</span><span class="code-line">   [] <span class="synStatement">-></span> [];
</span><span class="code-line">   (<span class="synStatement">::</span>) a t <span class="synStatement">-></span> (<span class="synStatement">::</span>) (f a) (map f t)}
</span></code></pre>
<p>正しいけど、あまり綺麗なコードじゃない。<br></p>
<pre class="code lang-haskell" data-lang="haskell" data-unlink=""><code class="code-highlight"><span class="code-line">map <span class="synStatement">::</span> (a <span class="synStatement">-></span> b) <span class="synStatement">-></span> (list a) <span class="synStatement">-></span> list b
</span><span class="code-line">map f [] <span class="synStatement">=</span> []
</span><span class="code-line">map f x<span class="synStatement">::</span>xs <span class="synStatement">=</span> (f x) <span class="synStatement">::</span> (map f xs)
</span></code></pre>
<p>くらいには変換してほしいけど、元の形からすると厳しいのかな。<br></p>
<p>次は <a class="keyword" href="http://d.hatena.ne.jp/keyword/scheme">scheme</a>.<br></p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Scheme.
</span><span class="code-line">Extraction map.</span></code></pre>
<pre class="code lang-scheme" data-lang="scheme" data-unlink=""><code class="code-highlight"><span class="code-line"><span class="synSpecial">(</span><span class="synStatement">define</span> <span class="synIdentifier">map</span> <span class="synSpecial">(</span>lambdas <span class="synSpecial">(</span>f l<span class="synSpecial">)</span>
</span><span class="code-line">  <span class="synSpecial">(</span>match l
</span><span class="code-line">     <span class="synSpecial">((</span>Nil<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Nil<span class="synSpecial">))</span>
</span><span class="code-line">     <span class="synSpecial">((</span><span class="synIdentifier">Cons</span> a t<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Cons <span class="synSpecial">,(</span>f a<span class="synSpecial">)</span> <span class="synSpecial">,(</span>@ <span class="synIdentifier">map</span> f t<span class="synSpecial">))))))</span>
</span></code></pre>
<p>おお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、<code>,</code>使った式展開も入ってる。<br>
Coq Extension <a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a> っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。<br>
lambdas マクロと @マクロはなかなかよい。<br>
<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> や <a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a> っぽく書きたい時は便利そう。<br>
match マクロは define-syntax みたいな感じかな？<br>
直接変換するならたしかにこういうマクロ欲しくなるな。<br></p>
<h2 id="insertion_sort-の変換">insertion_sort の変換</h2>
<h3 id="ocamlの場合"><a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a>の場合</h3>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Ocaml.
</span><span class="code-line">
</span><span class="code-line">Extract Inductive list => "list" ["[]" "(::)"].
</span><span class="code-line">Extract Inductive bool => "bool" ["true" "false"].
</span><span class="code-line">Extract Inductive nat => int ["0" "succ"] "(fun fO fS n -> if n = 0 then f O () else fS (n-1))".
</span><span class="code-line">Extraction insert.
</span><span class="code-line">Extraction insertion_sort.</span></code></pre>
<pre class="code lang-ocaml" data-lang="ocaml" data-unlink=""><code class="code-highlight"><span class="code-line"><span class="synComment">(** val insert : int -> int list -> int list **)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synStatement">let</span> <span class="synStatement">rec</span> insert a l <span class="synStatement">=</span> <span class="synStatement">match</span> l <span class="synStatement">with</span>
</span><span class="code-line"><span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-></span> a<span class="synStatement">::</span><span class="synConstant">[]</span>
</span><span class="code-line"><span class="synStatement">|</span> x<span class="synStatement">::</span>xs <span class="synStatement">-></span> <span class="synStatement">if</span> <span class="synPreProc">Nat</span>.leb a x <span class="synStatement">then</span> a<span class="synStatement">::</span>l <span class="synStatement">else</span> x<span class="synStatement">::(</span>insert a xs<span class="synStatement">)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synComment">(** val insertion_sort : int list -> int list **)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synStatement">let</span> <span class="synStatement">rec</span> insertion_sort <span class="synStatement">=</span> <span class="synStatement">function</span>
</span><span class="code-line"><span class="synStatement">|</span> <span class="synConstant">[]</span> <span class="synStatement">-></span> <span class="synConstant">[]</span>
</span><span class="code-line"><span class="synStatement">|</span> x<span class="synStatement">::</span>xs <span class="synStatement">-></span> insert x <span class="synStatement">(</span>insertion_sort xs<span class="synStatement">)</span>
</span></code></pre>
<h3 id="haskellの場合"><a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a>の場合</h3>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Haskell.
</span><span class="code-line">
</span><span class="code-line">Extract Inductive list => "([])" ["[]" "(:)"].
</span><span class="code-line">Extract Inductive bool => "Bool" ["True" "False"].
</span><span class="code-line">Extract Inductive nat => Int ["0" "succ"] "(\fO fS n -> if n == 0 then fO () else fS (n-1))".</span></code></pre>
<pre class="code lang-haskell" data-lang="haskell" data-unlink=""><code class="code-highlight"><span class="code-line">insert <span class="synStatement">::</span> Int <span class="synStatement">-></span> (([]) Int) <span class="synStatement">-></span> ([]) Int
</span><span class="code-line">insert a l <span class="synStatement">=</span>
</span><span class="code-line">  <span class="synStatement">case</span> l <span class="synStatement">of</span> {
</span><span class="code-line">   [] <span class="synStatement">-></span> (<span class="synStatement">:</span>) a [];
</span><span class="code-line">   (<span class="synStatement">:</span>) x xs <span class="synStatement">-></span>
</span><span class="code-line">    <span class="synStatement">case</span> leb a x <span class="synStatement">of</span> {
</span><span class="code-line">     True <span class="synStatement">-></span> (<span class="synStatement">:</span>) a l;
</span><span class="code-line">     False <span class="synStatement">-></span> (<span class="synStatement">:</span>) x (insert a xs)}}
</span><span class="code-line">
</span><span class="code-line">insertion_sort <span class="synStatement">::</span> (([]) Int) <span class="synStatement">-></span> ([]) Int
</span><span class="code-line">insertion_sort l <span class="synStatement">=</span>
</span><span class="code-line">  <span class="synStatement">case</span> l <span class="synStatement">of</span> {
</span><span class="code-line">   [] <span class="synStatement">-></span> [];
</span><span class="code-line">   (<span class="synStatement">:</span>) x xs <span class="synStatement">-></span> insert x (insertion_sort xs)}
</span></code></pre>
<h2 id="schemeの場合"><a class="keyword" href="http://d.hatena.ne.jp/keyword/Scheme">Scheme</a>の場合</h2>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Scheme.
</span><span class="code-line">
</span><span class="code-line">Extraction insert.
</span><span class="code-line">Extraction insertion_sort.</span></code></pre>
<pre class="code lang-scheme" data-lang="scheme" data-unlink=""><code class="code-highlight"><span class="code-line"><span class="synSpecial">(</span><span class="synStatement">define</span> insert <span class="synSpecial">(</span>lambdas <span class="synSpecial">(</span>a l<span class="synSpecial">)</span>
</span><span class="code-line">  <span class="synSpecial">(</span>match l
</span><span class="code-line">     <span class="synSpecial">((</span>Nil<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Cons <span class="synSpecial">,</span>a <span class="synSpecial">,`(</span>Nil<span class="synSpecial">)))</span>
</span><span class="code-line">     <span class="synSpecial">((</span><span class="synIdentifier">Cons</span> x xs<span class="synSpecial">)</span>
</span><span class="code-line">       <span class="synSpecial">(</span>match <span class="synSpecial">(</span>@ leb a x<span class="synSpecial">)</span>
</span><span class="code-line">          <span class="synSpecial">((</span>True<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Cons <span class="synSpecial">,</span>a <span class="synSpecial">,</span>l<span class="synSpecial">))</span>
</span><span class="code-line">          <span class="synSpecial">((</span>False<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Cons <span class="synSpecial">,</span>x <span class="synSpecial">,(</span>@ insert a xs<span class="synSpecial">))))))))</span>
</span><span class="code-line">
</span><span class="code-line"><span class="synSpecial">(</span><span class="synStatement">define</span> insertion_sort <span class="synSpecial">(</span><span class="synStatement">lambda</span> <span class="synSpecial">(</span>l<span class="synSpecial">)</span>
</span><span class="code-line">  <span class="synSpecial">(</span>match l
</span><span class="code-line">     <span class="synSpecial">((</span>Nil<span class="synSpecial">)</span> <span class="synSpecial">`(</span>Nil<span class="synSpecial">))</span>
</span><span class="code-line">     <span class="synSpecial">((</span><span class="synIdentifier">Cons</span> x xs<span class="synSpecial">)</span> <span class="synSpecial">(</span>@ insert x <span class="synSpecial">(</span>insertion_sort xs<span class="synSpecial">))))))</span>
</span></code></pre>
<h2 id="ファイルへの出力">ファイルへの出力</h2>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">Extraction Language Ocaml.
</span><span class="code-line">Extraction "insertion_sort.ml" insertion_sort.</span></code></pre>
<p>と入力して proof-general で C-c C-n すると以下のようなファイルが生成された。</p>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">module Nat =
</span><span class="code-line"> struct
</span><span class="code-line">  (** val leb : Int -> Int -> Bool **)
</span><span class="code-line">
</span><span class="code-line">  let rec leb n m =
</span><span class="code-line">    (\fO fS n -> if n == 0 then fO () else fS (n-1))
</span><span class="code-line">      (fun _ ->
</span><span class="code-line">      True)
</span><span class="code-line">      (fun n' ->
</span><span class="code-line">      (\fO fS n -> if n == 0 then fO () else fS (n-1))
</span><span class="code-line">        (fun _ ->
</span><span class="code-line">        False)
</span><span class="code-line">        (fun m' ->
</span><span class="code-line">        leb n' m')
</span><span class="code-line">        m)
</span><span class="code-line">      n
</span><span class="code-line"> end
</span><span class="code-line">
</span><span class="code-line">(** val insert : Int -> Int ([]) -> Int ([]) **)
</span><span class="code-line">
</span><span class="code-line">let rec insert a l = match l with
</span><span class="code-line">| [] -> a:[]
</span><span class="code-line">| x:xs ->
</span><span class="code-line">  (match Nat.leb a x with
</span><span class="code-line">   | True -> a:l
</span><span class="code-line">   | False -> x:(insert a xs))
</span><span class="code-line">
</span><span class="code-line">(** val insertion_sort : Int ([]) -> Int ([]) **)
</span><span class="code-line">
</span><span class="code-line">let rec insertion_sort = function
</span><span class="code-line">| [] -> []
</span><span class="code-line">| x:xs -> insert x (insertion_sort xs)</span></code></pre>
<pre class="code" data-lang="" data-unlink=""><code class="code-highlight"><span class="code-line">module Nat :
</span><span class="code-line"> sig
</span><span class="code-line">  val leb : Int -> Int -> Bool
</span><span class="code-line"> end
</span><span class="code-line">
</span><span class="code-line">val insert : Int -> Int ([]) -> Int ([])
</span><span class="code-line">
</span><span class="code-line">val insertion_sort : Int ([]) -> Int ([])</span></code></pre>
<p>lebも作ってくれるのか。
まあないとコードにならないもんな。</p>
<h2 id="証明駆動開発のステップ">証明駆動開発のステップ</h2>
<ol>
<li>まず書こうとしているプログラムがどういう性質をみたすべきかを記述し、</li>
<li>Coq でそれをみたすようなプログラムを書き、</li>
<li>実際に最初に考えた性質を証明し、</li>
<li>Extraction して他の言語のコードに変換する</li>
</ol>
<h2 id="感想">感想</h2>
<p>形式証明が慣れてないからなのかとても難しかった。<br>
ただ、証明のステップを追うのはとても気持ちよかった。<br></p>
<p>次は、最近発売された純粋関数型データ構造読むかなって気分。<br>
SML で書かれているらしいから、<a class="keyword" href="http://d.hatena.ne.jp/keyword/OCaml">OCaml</a> に置き換えながら写経するのが楽かな？<br>
それとも付録に <a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a> 実装があるらしいので <a class="keyword" href="http://d.hatena.ne.jp/keyword/Haskell">Haskell</a> に置き換えながら写経して、書けたら答え合わせするほうがいいかな。<br>
悩ましい。</p></div></div></article></div></div><div class="flex md:justify-center w-full"><div class="flex flex-col md:max-w-4xl w-full"><hr/><div class="flex justify-center pt-4 pb-8">© 2022 wat-aro</div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"プログラミング Coq (証明駆動開発 2)","published":"2017/05/11","tags":[],"content":"\n\u003cp\u003e\u003ca href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html\"\u003e\u0026#x8A3C;\u0026#x660E;\u0026#x99C6;\u0026#x52D5;\u0026#x958B;\u0026#x767A;\u0026#x5165;\u0026#x9580;(2)\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e上記ページの勉強メモです。\u003c/p\u003e\n\n\u003ch1\u003eExtraction\u003c/h1\u003e\n\n\u003cp\u003ecoq から \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e のコードを出力する。\u003cbr\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e にコードを出力するにはそのまま\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction map.\u003c/pre\u003e\n\n\n\u003cp\u003eとすればいい。\u003cbr\u003e\nこれで\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e(** val map : ('a1 -\u0026gt; 'a2) -\u0026gt; 'a1 list -\u0026gt; 'a2 list **)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e map f \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eNil\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eNil\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eCons\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003ea, t\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eCons\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e((\u003c/span\u003ef a\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003emap f t\u003cspan class=\"synStatement\"\u003e))\u003c/span\u003e\n\u003c/pre\u003e\n\n\n\u003cp\u003eと出力される。（proof-general を使っています。coq-\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\"\u003eide\u003c/a\u003eの場合はcommand pane で実行）\u003cbr\u003e\u003c/p\u003e\n\n\u003cp\u003eこの時、list が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストでなく coq で定義された list になっている。\u003cbr\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストを使うには\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtract Inductive list =\u0026gt; \u0026#34;list\u0026#34; [\u0026#34;[]\u0026#34; \u0026#34;(::)\u0026#34;].\u003c/pre\u003e\n\n\n\u003cp\u003eを実行する。こうすると\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e(** val map : ('a1 -\u0026gt; 'a2) -\u0026gt; 'a1 list -\u0026gt; 'a2 list **)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e map f \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003et \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003ef a\u003cspan class=\"synStatement\"\u003e)::(\u003c/span\u003emap f t\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\u003c/pre\u003e\n\n\n\u003cp\u003eと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストを使ったmap関数が生成される。\u003cbr\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e  や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e に出力するにはそれぞれ\u003cbr\u003e\n\u003ccode\u003eExtraction Language Haskell.\u003c/code\u003e \u003ccode\u003eExtraction Language Scheme.\u003c/code\u003e としてから\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003eの場合と同じように出力する。\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Haskell.\nExtract Inductive list =\u0026gt; \u0026#34;list\u0026#34; [\u0026#34;[]\u0026#34; \u0026#34;(::)\u0026#34;].\nExtraction map.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003emap \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (a1 \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a2) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (list a1) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e list a2\nmap f l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n   [] \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e [];\n   (\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e) a t \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e) (f a) (map f t)}\n\u003c/pre\u003e\n\n\n\u003cp\u003e正しいけど、あまり綺麗なコードじゃない。\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003emap \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (a \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e b) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (list a) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e list b\nmap f [] \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e []\nmap f x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e (f x) \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (map f xs)\n\u003c/pre\u003e\n\n\n\u003cp\u003eくらいには変換してほしいけど、元の形からすると厳しいのかな。\u003cbr\u003e\u003c/p\u003e\n\n\u003cp\u003e次は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/scheme\"\u003escheme\u003c/a\u003e.\u003cbr\u003e\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Scheme.\nExtraction map.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink\u003e\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003elambdas \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ef l\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e a t\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003ef a\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003e@ \u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e f t\u003cspan class=\"synSpecial\"\u003e))))))\u003c/span\u003e\n\u003c/pre\u003e\n\n\n\u003cp\u003eおお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、\u003ccode\u003e,\u003c/code\u003e使った式展開も入ってる。\u003cbr\u003e\nCoq Extension \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。\u003cbr\u003e\nlambdas マクロと @マクロはなかなかよい。\u003cbr\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e っぽく書きたい時は便利そう。\u003cbr\u003e\nmatch マクロは define-syntax みたいな感じかな？\u003cbr\u003e\n直接変換するならたしかにこういうマクロ欲しくなるな。\u003cbr\u003e\u003c/p\u003e\n\n\u003ch2\u003einsertion_sort の変換\u003c/h2\u003e\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003eの場合\u003c/h3\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Ocaml.\n\nExtract Inductive list =\u0026gt; \u0026#34;list\u0026#34; [\u0026#34;[]\u0026#34; \u0026#34;(::)\u0026#34;].\nExtract Inductive bool =\u0026gt; \u0026#34;bool\u0026#34; [\u0026#34;true\u0026#34; \u0026#34;false\u0026#34;].\nExtract Inductive nat =\u0026gt; int [\u0026#34;0\u0026#34; \u0026#34;succ\u0026#34;] \u0026#34;(fun fO fS n -\u0026gt; if n = 0 then f O () else fS (n-1))\u0026#34;.\nExtraction insert.\nExtraction insertion_sort.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink\u003e\u003cspan class=\"synComment\"\u003e(** val insert : int -\u0026gt; int list -\u0026gt; int list **)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e insert a l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003ewith\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eNat\u003c/span\u003e.leb a x \u003cspan class=\"synStatement\"\u003ethen\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003el \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::(\u003c/span\u003einsert a xs\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"synComment\"\u003e(** val insertion_sort : int list -\u0026gt; int list **)\u003c/span\u003e\n\n\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e insertion_sort \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e insert x \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003einsertion_sort xs\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\u003c/pre\u003e\n\n\n\u003ch3\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの場合\u003c/h3\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Haskell.\n\nExtract Inductive list =\u0026gt; \u0026#34;([])\u0026#34; [\u0026#34;[]\u0026#34; \u0026#34;(:)\u0026#34;].\nExtract Inductive bool =\u0026gt; \u0026#34;Bool\u0026#34; [\u0026#34;True\u0026#34; \u0026#34;False\u0026#34;].\nExtract Inductive nat =\u0026gt; Int [\u0026#34;0\u0026#34; \u0026#34;succ\u0026#34;] \u0026#34;(\\fO fS n -\u0026gt; if n == 0 then fO () else fS (n-1))\u0026#34;.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink\u003einsert \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Int \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (([]) Int) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ([]) Int\ninsert a l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n   [] \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) a [];\n   (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x xs \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e leb a x \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n     True \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) a l;\n     False \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x (insert a xs)}}\n\ninsertion_sort \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (([]) Int) \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e ([]) Int\ninsertion_sort l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n   [] \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e [];\n   (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x xs \u003cspan class=\"synStatement\"\u003e-\u0026gt;\u003c/span\u003e insert x (insertion_sort xs)}\n\u003c/pre\u003e\n\n\n\u003ch2\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003eの場合\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Scheme.\n\nExtraction insert.\nExtraction insertion_sort.\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink\u003e\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e insert \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003elambdas \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ea l\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ea \u003cspan class=\"synSpecial\"\u003e,`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)))\u003c/span\u003e\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e x xs\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n       \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e@ leb a x\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n          \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eTrue\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ea \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003el\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n          \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eFalse\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ex \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003e@ insert a xs\u003cspan class=\"synSpecial\"\u003e))))))))\u003c/span\u003e\n\n\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e insertion_sort \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003elambda\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003el\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e x xs\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e@ insert x \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003einsertion_sort xs\u003cspan class=\"synSpecial\"\u003e))))))\u003c/span\u003e\n\u003c/pre\u003e\n\n\n\u003ch2\u003eファイルへの出力\u003c/h2\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003eExtraction Language Ocaml.\nExtraction \u0026#34;insertion_sort.ml\u0026#34; insertion_sort.\u003c/pre\u003e\n\n\n\u003cp\u003eと入力して proof-general で C-c C-n すると以下のようなファイルが生成された。\u003c/p\u003e\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Nat =\n struct\n  (** val leb : Int -\u0026gt; Int -\u0026gt; Bool **)\n\n  let rec leb n m =\n    (\\fO fS n -\u0026gt; if n == 0 then fO () else fS (n-1))\n      (fun _ -\u0026gt;\n      True)\n      (fun n\u0026#39; -\u0026gt;\n      (\\fO fS n -\u0026gt; if n == 0 then fO () else fS (n-1))\n        (fun _ -\u0026gt;\n        False)\n        (fun m\u0026#39; -\u0026gt;\n        leb n\u0026#39; m\u0026#39;)\n        m)\n      n\n end\n\n(** val insert : Int -\u0026gt; Int ([]) -\u0026gt; Int ([]) **)\n\nlet rec insert a l = match l with\n| [] -\u0026gt; a:[]\n| x:xs -\u0026gt;\n  (match Nat.leb a x with\n   | True -\u0026gt; a:l\n   | False -\u0026gt; x:(insert a xs))\n\n(** val insertion_sort : Int ([]) -\u0026gt; Int ([]) **)\n\nlet rec insertion_sort = function\n| [] -\u0026gt; []\n| x:xs -\u0026gt; insert x (insertion_sort xs)\u003c/pre\u003e\n\n\n\n\n\u003cpre class=\"code\" data-lang=\"\" data-unlink\u003emodule Nat :\n sig\n  val leb : Int -\u0026gt; Int -\u0026gt; Bool\n end\n\nval insert : Int -\u0026gt; Int ([]) -\u0026gt; Int ([])\n\nval insertion_sort : Int ([]) -\u0026gt; Int ([])\u003c/pre\u003e\n\n\n\u003cp\u003elebも作ってくれるのか。\nまあないとコードにならないもんな。\u003c/p\u003e\n\n\u003ch2\u003e証明駆動開発のステップ\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003eまず書こうとしているプログラムがどういう性質をみたすべきかを記述し、\u003c/li\u003e\n\u003cli\u003eCoq でそれをみたすようなプログラムを書き、\u003c/li\u003e\n\u003cli\u003e実際に最初に考えた性質を証明し、\u003c/li\u003e\n\u003cli\u003eExtraction して他の言語のコードに変換する\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003ch2\u003e感想\u003c/h2\u003e\n\n\u003cp\u003e形式証明が慣れてないからなのかとても難しかった。\u003cbr\u003e\nただ、証明のステップを追うのはとても気持ちよかった。\u003cbr\u003e\u003c/p\u003e\n\n\u003cp\u003e次は、最近発売された純粋関数型データ構造読むかなって気分。\u003cbr\u003e\nSML で書かれているらしいから、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e に置き換えながら写経するのが楽かな？\u003cbr\u003e\nそれとも付録に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e 実装があるらしいので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e に置き換えながら写経して、書けたら答え合わせするほうがいいかな。\u003cbr\u003e\n悩ましい。\u003c/p\u003e\n\n","slug":"プログラミング Coq (証明駆動開発 2)"},"content":"\u003cp\u003e\u003ca href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html\"\u003e証明駆動開発入門(2)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e上記ページの勉強メモです。\u003c/p\u003e\n\u003ch1 id=\"extraction\"\u003eExtraction\u003c/h1\u003e\n\u003cp\u003ecoq から \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e, \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e のコードを出力する。\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e にコードを出力するにはそのまま\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction map.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eとすればいい。\u003cbr\u003e\nこれで\u003c/p\u003e\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synComment\"\u003e(** val map : ('a1 -\u003e 'a2) -\u003e 'a1 list -\u003e 'a2 list **)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e map f \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eNil\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eNil\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eCons\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003ea, t\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synConstant\"\u003eCons\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e((\u003c/span\u003ef a\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e, \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003emap f t\u003cspan class=\"synStatement\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと出力される。（proof-general を使っています。coq-\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\"\u003eide\u003c/a\u003eの場合はcommand pane で実行）\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eこの時、list が \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストでなく coq で定義された list になっている。\u003cbr\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストを使うには\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive list =\u003e \"list\" [\"[]\" \"(::)\"].\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eを実行する。こうすると\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synComment\"\u003e(** val map : ('a1 -\u003e 'a2) -\u003e 'a1 list -\u003e 'a2 list **)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e map f \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003et \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003ef a\u003cspan class=\"synStatement\"\u003e)::(\u003c/span\u003emap f t\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e 組み込みのリストを使ったmap関数が生成される。\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e  や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e に出力するにはそれぞれ\u003cbr\u003e\n\u003ccode\u003eExtraction Language Haskell.\u003c/code\u003e \u003ccode\u003eExtraction Language Scheme.\u003c/code\u003e としてから\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003eの場合と同じように出力する。\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Haskell.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive list =\u003e \"list\" [\"[]\" \"(::)\"].\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction map.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003emap \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (a1 \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e a2) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (list a1) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e list a2\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003emap f l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   [] \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e [];\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   (\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e) a t \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e) (f a) (map f t)}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e正しいけど、あまり綺麗なコードじゃない。\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003emap \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (a \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e b) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (list a) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e list b\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003emap f [] \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e []\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003emap f x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e (f x) \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (map f xs)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eくらいには変換してほしいけど、元の形からすると厳しいのかな。\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003e次は \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/scheme\"\u003escheme\u003c/a\u003e.\u003cbr\u003e\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Scheme.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction map.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e \u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003elambdas \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ef l\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e a t\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003ef a\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003e@ \u003cspan class=\"synIdentifier\"\u003emap\u003c/span\u003e f t\u003cspan class=\"synSpecial\"\u003e))))))\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eおお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、\u003ccode\u003e,\u003c/code\u003e使った式展開も入ってる。\u003cbr\u003e\nCoq Extension \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003e っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。\u003cbr\u003e\nlambdas マクロと @マクロはなかなかよい。\u003cbr\u003e\n\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e や \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e っぽく書きたい時は便利そう。\u003cbr\u003e\nmatch マクロは define-syntax みたいな感じかな？\u003cbr\u003e\n直接変換するならたしかにこういうマクロ欲しくなるな。\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id=\"insertion_sort-の変換\"\u003einsertion_sort の変換\u003c/h2\u003e\n\u003ch3 id=\"ocamlの場合\"\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003eの場合\u003c/h3\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Ocaml.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive list =\u003e \"list\" [\"[]\" \"(::)\"].\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive bool =\u003e \"bool\" [\"true\" \"false\"].\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive nat =\u003e int [\"0\" \"succ\"] \"(fun fO fS n -\u003e if n = 0 then f O () else fS (n-1))\".\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction insert.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction insertion_sort.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synComment\"\u003e(** val insert : int -\u003e int list -\u003e int list **)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e insert a l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003ematch\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003ewith\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e\u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synStatement\"\u003eif\u003c/span\u003e \u003cspan class=\"synPreProc\"\u003eNat\u003c/span\u003e.leb a x \u003cspan class=\"synStatement\"\u003ethen\u003c/span\u003e a\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003el \u003cspan class=\"synStatement\"\u003eelse\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::(\u003c/span\u003einsert a xs\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synComment\"\u003e(** val insertion_sort : int list -\u003e int list **)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003elet\u003c/span\u003e \u003cspan class=\"synStatement\"\u003erec\u003c/span\u003e insertion_sort \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e \u003cspan class=\"synStatement\"\u003efunction\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"synConstant\"\u003e[]\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synStatement\"\u003e|\u003c/span\u003e x\u003cspan class=\"synStatement\"\u003e::\u003c/span\u003exs \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e insert x \u003cspan class=\"synStatement\"\u003e(\u003c/span\u003einsertion_sort xs\u003cspan class=\"synStatement\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"haskellの場合\"\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003eの場合\u003c/h3\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Haskell.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive list =\u003e \"([])\" [\"[]\" \"(:)\"].\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive bool =\u003e \"Bool\" [\"True\" \"False\"].\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtract Inductive nat =\u003e Int [\"0\" \"succ\"] \"(\\fO fS n -\u003e if n == 0 then fO () else fS (n-1))\".\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003einsert \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e Int \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (([]) Int) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e ([]) Int\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003einsert a l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   [] \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) a [];\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x xs \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e    \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e leb a x \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     True \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) a l;\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     False \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x (insert a xs)}}\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003einsertion_sort \u003cspan class=\"synStatement\"\u003e::\u003c/span\u003e (([]) Int) \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e ([]) Int\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003einsertion_sort l \u003cspan class=\"synStatement\"\u003e=\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synStatement\"\u003ecase\u003c/span\u003e l \u003cspan class=\"synStatement\"\u003eof\u003c/span\u003e {\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   [] \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e [];\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   (\u003cspan class=\"synStatement\"\u003e:\u003c/span\u003e) x xs \u003cspan class=\"synStatement\"\u003e-\u003e\u003c/span\u003e insert x (insertion_sort xs)}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"schemeの場合\"\u003e\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\"\u003eScheme\u003c/a\u003eの場合\u003c/h2\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Scheme.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction insert.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction insertion_sort.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e insert \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003elambdas \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ea l\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ea \u003cspan class=\"synSpecial\"\u003e,`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)))\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e x xs\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e       \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e@ leb a x\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e          \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eTrue\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ea \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003el\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e          \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eFalse\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eCons \u003cspan class=\"synSpecial\"\u003e,\u003c/span\u003ex \u003cspan class=\"synSpecial\"\u003e,(\u003c/span\u003e@ insert a xs\u003cspan class=\"synSpecial\"\u003e))))))))\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003edefine\u003c/span\u003e insertion_sort \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e\u003cspan class=\"synStatement\"\u003elambda\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003el\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003ematch l\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e`(\u003c/span\u003eNil\u003cspan class=\"synSpecial\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e     \u003cspan class=\"synSpecial\"\u003e((\u003c/span\u003e\u003cspan class=\"synIdentifier\"\u003eCons\u003c/span\u003e x xs\u003cspan class=\"synSpecial\"\u003e)\u003c/span\u003e \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003e@ insert x \u003cspan class=\"synSpecial\"\u003e(\u003c/span\u003einsertion_sort xs\u003cspan class=\"synSpecial\"\u003e))))))\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"ファイルへの出力\"\u003eファイルへの出力\u003c/h2\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003eExtraction Language Ocaml.\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eExtraction \"insertion_sort.ml\" insertion_sort.\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eと入力して proof-general で C-c C-n すると以下のようなファイルが生成された。\u003c/p\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003emodule Nat =\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e struct\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  (** val leb : Int -\u003e Int -\u003e Bool **)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  let rec leb n m =\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e    (\\fO fS n -\u003e if n == 0 then fO () else fS (n-1))\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      (fun _ -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      True)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      (fun n' -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      (\\fO fS n -\u003e if n == 0 then fO () else fS (n-1))\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e        (fun _ -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e        False)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e        (fun m' -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e        leb n' m')\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e        m)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e      n\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e end\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e(** val insert : Int -\u003e Int ([]) -\u003e Int ([]) **)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003elet rec insert a l = match l with\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e| [] -\u003e a:[]\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e| x:xs -\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  (match Nat.leb a x with\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   | True -\u003e a:l\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e   | False -\u003e x:(insert a xs))\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e(** val insertion_sort : Int ([]) -\u003e Int ([]) **)\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003elet rec insertion_sort = function\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e| [] -\u003e []\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e| x:xs -\u003e insert x (insertion_sort xs)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"code\" data-lang=\"\" data-unlink=\"\"\u003e\u003ccode class=\"code-highlight\"\u003e\u003cspan class=\"code-line\"\u003emodule Nat :\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e sig\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e  val leb : Int -\u003e Int -\u003e Bool\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e end\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eval insert : Int -\u003e Int ([]) -\u003e Int ([])\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003e\n\u003c/span\u003e\u003cspan class=\"code-line\"\u003eval insertion_sort : Int ([]) -\u003e Int ([])\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elebも作ってくれるのか。\nまあないとコードにならないもんな。\u003c/p\u003e\n\u003ch2 id=\"証明駆動開発のステップ\"\u003e証明駆動開発のステップ\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eまず書こうとしているプログラムがどういう性質をみたすべきかを記述し、\u003c/li\u003e\n\u003cli\u003eCoq でそれをみたすようなプログラムを書き、\u003c/li\u003e\n\u003cli\u003e実際に最初に考えた性質を証明し、\u003c/li\u003e\n\u003cli\u003eExtraction して他の言語のコードに変換する\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"感想\"\u003e感想\u003c/h2\u003e\n\u003cp\u003e形式証明が慣れてないからなのかとても難しかった。\u003cbr\u003e\nただ、証明のステップを追うのはとても気持ちよかった。\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003e次は、最近発売された純粋関数型データ構造読むかなって気分。\u003cbr\u003e\nSML で書かれているらしいから、\u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\"\u003eOCaml\u003c/a\u003e に置き換えながら写経するのが楽かな？\u003cbr\u003e\nそれとも付録に \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e 実装があるらしいので \u003ca class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\"\u003eHaskell\u003c/a\u003e に置き換えながら写経して、書けたら答え合わせするほうがいいかな。\u003cbr\u003e\n悩ましい。\u003c/p\u003e"},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"プログラミング Coq (証明駆動開発 2)"},"buildId":"VmuCmjWVz9JrsUnu1Nh0c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>