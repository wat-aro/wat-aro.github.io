<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="title" content="(wat-aro)"/><meta name="description" content="wat-aro のサイト"/><meta property="og:locale" content="ja_jp"/><meta property="og:type" content="article"/><meta property="og:site_name" content="(wat-aro)"/><meta property="og:title" content="(wat-aro)"/><meta property="og:image" content="https://wat-aro.dev/images/default-ogimage.png"/><meta property="og:url" content="https://wat-aro.dev/slides/feeling-to-type-ruby"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@wat_aro"/><meta name="twitter:creator" content="@wat_aro"/><meta name="twitter:title" content="(wat-aro)"/><meta name="twitter:description" content="wat-aro のサイト"/><meta name="twitter:image" content="https://wat-aro.dev/images/default-ogimage.png"/><meta name="next-head-count" content="16"/><link rel="icon" href="/images/favicon.ico"/><link rel="preload" href="/_next/static/css/cef7709dba1aabcc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cef7709dba1aabcc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2b5404e9d344d383.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2b5404e9d344d383.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-e7be5a2ce3007f17.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-847cc7a6659a518e.js" defer=""></script><script src="/_next/static/chunks/pages/slides/%5Bslug%5D-2c380248fcce344d.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_buildManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_ssgManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_middlewareManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MW6D56L" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="py-0 md:px-8 min-h-screen flex flex-col items-center"><div class="top-0 bg-white w-full h-16 flex flex-row justify-between items-center px-4 border-b-2"><a href="/"><div class="flex items-center font-midium text-3xl h-full font-bold gap-4"><img class="rounded-full" src="/images/profile.jpg" width="48" height="48" alt="profile image"/>(wat-aro)<!-- --></div></a><ul class="flex gap-3 h-full"><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/posts">Blog</a></li><li class="h-full flex flex-col justify-end border-black pb-3 border-b-4"><a href="/slides">Slide</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/about">About</a></li></ul></div><div class="flex md:justify-center justify-between w-full flex-grow"><div class="flex flex-col sm:max-w-sm md:max-w-4xl w-full py-4 px-4"><div class="top-0 left-0 w-full h-full"><div class="reveal"><div class="slides">
        <section data-markdown data-separator-vertical="^===
">
          <textarea data-template>
            # Ruby に型をつけるお気持ち

wat-aro

---

## 自己紹介

- wat-aro
- Haskell, Elm なんかが好き

---

## おしながき

- Ruby の型のおさらい
- ruby-signature の記法
- 実例を通して

---

### `Ruby` の型のおさらい

- 型検査器 steep, sorbet
- rbi ファイルに型定義を書くがそれぞれ文法が違う
- Ruby 3 では型シグネチャが導入される
- 周辺ツール群は外部ライブラリとして提供

---

### `Ruby` の型シグナチャ

- ruby-signature
- https://github.com/ruby/ruby-signature
- steep, sorbet にこのシグネチャを使ってもらう

---

---

## `ruby-signature` の記法

- プリミティブな型は Class instance type で定義
- Interface type であるメソッドを持った型というのも定義できる
- Literal type, Union Type, Intersection type, Optional type で柔軟な型定義ができる
- ivar や メソッドの型定義も直観的
- 型付けできないものは `untyped`

---

### プリミティブな型

- Integer
- String
- Hash[Symbol, String]

---

### `Record type`

- Hash の型を指定
- `{ id: Integer, name: String }`

---

### `Interface type`

例: each メソッドを持っている型

```ruby
interface _Each[A, B]
  def each: { (A) -> void } -> B
end
```

---

### `Literal type`

- 型の取り得る値を限定できる
- `1` という型は Integer かつ 値を `1` に限定
- "hello world"という型や`:to_s`という型を定義可能

---

### `Union type`

- 型の和を表わす
- `Integer | String` は Integer or String

---

### `Intersection type`

- 交差型
- `Integer & String` は Integer and String
- Hash の合成が主な用途？
- `{ id: Integer } & { name: String }` は `{ id: Integer, name: String }`

---

### `Optional type`

- みんな大好き null 安全
- `Integer?` で `Integer | nil`

---

### ivar やメソッドの型定義

- `@name: String` で ivar
- `def to_s: () -> String` でメソッドを定義

---

### 所見

- TypeScript の影響が強い
  - Literal type
  - Intersection type
- Interface type があればダックタイプもやりやすそう
- 想像していたよりもリッチ
- any じゃなくて untyped なのはわかりやすくていい

---

---

## 実例を通して

ruby-signature はまだ StandardLibrary の片付けが終わっていないので
適当なものに型をつけてみる

---

### Abbrev モジュール

- StandardLibrary で最初に表示されている
- module_function abbrev 一つだけのモジュールなので簡単
- まだ ruby-signature で定義されていない

---

### Abbrev#abbrev とは

`abbrev(words, pattern = nil)`

```ruby
Abbrev.abbrev(['ruby'])
#=>  {"ruby"=>"ruby", "rub"=>"ruby", "ru"=>"ruby", "r"=>"ruby"}

Abbrev.abbrev(%w{ car cone })
#=> {"ca"=>"car", "con"=>"cone", "co"=>"cone", "car"=>"car", "cone"=>"cone"}

Abbrev.abbrev(%w{car box cone crab}, /b/)
#=> {"box"=>"box", "bo"=>"box", "b"=>"box", "crab" => "crab"}

Abbrev.abbrev(%w{car box cone}, 'ca')
#=> {"car"=>"car", "ca"=>"car"}
```

String の配列をうけとり、String を分解して key とし、元の String を value とする Hash を返す

---

### まずはシンプルなケース

```ruby
Abbrev.abbrev(['ruby'])
#=>  {"ruby"=>"ruby", "rub"=>"ruby", "ru"=>"ruby", "r"=>"ruby"}
```

これに型を付けると

```ruby
module Abbrev
  def self?.abbrev: (Array[String]) -> Hash[String, String]
end
```

`def self?` は module function 用の書き方
空配列を受け取っても空ハッシュを返すだけなので問題なし。

---

### 第 2 引数について

example を見ると String と Regexp を受け取ることを想定しているよう

```ruby
Abbrev.abbrev(%w{car box cone crab}, /b/)
#=> {"box"=>"box", "bo"=>"box", "b"=>"box", "crab" => "crab"}

Abbrev.abbrev(%w{car box cone}, 'ca')
#=> {"car"=>"car", "ca"=>"car"}
```

じゃあ Integer とか渡したらエラーになるのかな？

---

### 想定していなさそうな型の引数を渡してみる

```ruby
Abbrev.abbrev(%w{12345}, 1)
#=> {}
```

エラーにならないだと…
この場合って型はどうつければいいのか。
実装を abbrev の実装を見てみると

---

### abbrev の実装

- String, Regexp 以外は `!~` を直接使っている
- `Integer#!~` は常に true を返す

```ruby
def abbrev(words, pattern = nil)
  ...
  if pattern.is_a?(String)
    pattern = /\A#{Regexp.quote(pattern)}/  # regard as a prefix
  end
```

```ruby
  words.each do |word|
    next if word.empty?
    word.size.downto(1) { |len|
      abbrev = word[0...len]
      next if pattern && pattern !~ abbrev
      ...
    }
  end
end
```

```ruby
  words.each do |word|
    next if pattern && pattern !~ word
    table[word] = word
  end
  table
end
```

---

### abbrev の第 2 引数は String, Regexp 以外を考慮していない

- String, Regexp 以外を考慮しておらず、たまたま `{}` を返すようになっているだけに見える
- 実行時にエラーにならない場合はどう型をつければよいのか
  - Integer or Object を引数に取ることを認める
  - String と Regexp 以外は認めない

---

### このような場合にどうすればよいか

- ドキュメントにどう書かれているか
- エラーでないために困る場合を想定してどう検査してほしいかを考える

---

### ドキュメント

> The optional pattern parameter is a pattern or a string.
> Only input strings that match the pattern or start with the string are included in the output hash.

pattern とは言っているけれど、それが Regexp とは限定していない。

---

### エラーでないために困る場合を想定してどう検査してほしいかを考える

何かのメソッドの返り値が String や Regexp だと思っていたのに Integer だった場合

```ruby
def some_method: () -> (String | Integer)

pattern = some_method()

Abbrev.abbrev(["12345"], pattern)
#=> {}
```

Integer が来てここでエラーにならなくてもその後で不整合がおこる場合に困る。
ここを通るテストがない場合になぜ駄目なのかの調査が必要になる。
それよりも型検査で弾いてくれたほうが嬉しい。

---

### 結果

```ruby
module Abbrev
  def self?.abbrev: (Array[String], ?(String | Regexp | nil)) -> Hash[String, String]
end

```

第 2 引数は String, Regexp, nil としました。
この定義で ruby-signature に PR を送ってマージされた。

---

## まとめ

- ruby-signature の紹介
- ドキュメントにない場合でもそれっぽく動く場合がある
- どう動いてほしいかを考えて型をつけないといけない場合がある

          </textarea>
        </section>
    </div></div></div></div></div><div class="flex md:justify-center w-full"><div class="flex flex-col md:max-w-4xl w-full"><hr/><div class="flex justify-center pt-4 pb-8">© 2022 wat-aro</div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slide":{"title":"Ruby に型をつけるお気持ち","published":"2020/01/15","tags":["Ruby"],"slug":"feeling-to-type-ruby","content":"# Ruby に型をつけるお気持ち\n\nwat-aro\n\n---\n\n## 自己紹介\n\n- wat-aro\n- Haskell, Elm なんかが好き\n\n---\n\n## おしながき\n\n- Ruby の型のおさらい\n- ruby-signature の記法\n- 実例を通して\n\n---\n\n### `Ruby` の型のおさらい\n\n- 型検査器 steep, sorbet\n- rbi ファイルに型定義を書くがそれぞれ文法が違う\n- Ruby 3 では型シグネチャが導入される\n- 周辺ツール群は外部ライブラリとして提供\n\n---\n\n### `Ruby` の型シグナチャ\n\n- ruby-signature\n- https://github.com/ruby/ruby-signature\n- steep, sorbet にこのシグネチャを使ってもらう\n\n---\n\n---\n\n## `ruby-signature` の記法\n\n- プリミティブな型は Class instance type で定義\n- Interface type であるメソッドを持った型というのも定義できる\n- Literal type, Union Type, Intersection type, Optional type で柔軟な型定義ができる\n- ivar や メソッドの型定義も直観的\n- 型付けできないものは `untyped`\n\n---\n\n### プリミティブな型\n\n- Integer\n- String\n- Hash[Symbol, String]\n\n---\n\n### `Record type`\n\n- Hash の型を指定\n- `{ id: Integer, name: String }`\n\n---\n\n### `Interface type`\n\n例: each メソッドを持っている型\n\n```ruby\ninterface _Each[A, B]\n  def each: { (A) -\u003e void } -\u003e B\nend\n```\n\n---\n\n### `Literal type`\n\n- 型の取り得る値を限定できる\n- `1` という型は Integer かつ 値を `1` に限定\n- \"hello world\"という型や`:to_s`という型を定義可能\n\n---\n\n### `Union type`\n\n- 型の和を表わす\n- `Integer | String` は Integer or String\n\n---\n\n### `Intersection type`\n\n- 交差型\n- `Integer \u0026 String` は Integer and String\n- Hash の合成が主な用途？\n- `{ id: Integer } \u0026 { name: String }` は `{ id: Integer, name: String }`\n\n---\n\n### `Optional type`\n\n- みんな大好き null 安全\n- `Integer?` で `Integer | nil`\n\n---\n\n### ivar やメソッドの型定義\n\n- `@name: String` で ivar\n- `def to_s: () -\u003e String` でメソッドを定義\n\n---\n\n### 所見\n\n- TypeScript の影響が強い\n  - Literal type\n  - Intersection type\n- Interface type があればダックタイプもやりやすそう\n- 想像していたよりもリッチ\n- any じゃなくて untyped なのはわかりやすくていい\n\n---\n\n---\n\n## 実例を通して\n\nruby-signature はまだ StandardLibrary の片付けが終わっていないので\n適当なものに型をつけてみる\n\n---\n\n### Abbrev モジュール\n\n- StandardLibrary で最初に表示されている\n- module_function abbrev 一つだけのモジュールなので簡単\n- まだ ruby-signature で定義されていない\n\n---\n\n### Abbrev#abbrev とは\n\n`abbrev(words, pattern = nil)`\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=\u003e  {\"ruby\"=\u003e\"ruby\", \"rub\"=\u003e\"ruby\", \"ru\"=\u003e\"ruby\", \"r\"=\u003e\"ruby\"}\n\nAbbrev.abbrev(%w{ car cone })\n#=\u003e {\"ca\"=\u003e\"car\", \"con\"=\u003e\"cone\", \"co\"=\u003e\"cone\", \"car\"=\u003e\"car\", \"cone\"=\u003e\"cone\"}\n\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=\u003e {\"box\"=\u003e\"box\", \"bo\"=\u003e\"box\", \"b\"=\u003e\"box\", \"crab\" =\u003e \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=\u003e {\"car\"=\u003e\"car\", \"ca\"=\u003e\"car\"}\n```\n\nString の配列をうけとり、String を分解して key とし、元の String を value とする Hash を返す\n\n---\n\n### まずはシンプルなケース\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=\u003e  {\"ruby\"=\u003e\"ruby\", \"rub\"=\u003e\"ruby\", \"ru\"=\u003e\"ruby\", \"r\"=\u003e\"ruby\"}\n```\n\nこれに型を付けると\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String]) -\u003e Hash[String, String]\nend\n```\n\n`def self?` は module function 用の書き方\n空配列を受け取っても空ハッシュを返すだけなので問題なし。\n\n---\n\n### 第 2 引数について\n\nexample を見ると String と Regexp を受け取ることを想定しているよう\n\n```ruby\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=\u003e {\"box\"=\u003e\"box\", \"bo\"=\u003e\"box\", \"b\"=\u003e\"box\", \"crab\" =\u003e \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=\u003e {\"car\"=\u003e\"car\", \"ca\"=\u003e\"car\"}\n```\n\nじゃあ Integer とか渡したらエラーになるのかな？\n\n---\n\n### 想定していなさそうな型の引数を渡してみる\n\n```ruby\nAbbrev.abbrev(%w{12345}, 1)\n#=\u003e {}\n```\n\nエラーにならないだと…\nこの場合って型はどうつければいいのか。\n実装を abbrev の実装を見てみると\n\n---\n\n### abbrev の実装\n\n- String, Regexp 以外は `!~` を直接使っている\n- `Integer#!~` は常に true を返す\n\n```ruby\ndef abbrev(words, pattern = nil)\n  ...\n  if pattern.is_a?(String)\n    pattern = /\\A#{Regexp.quote(pattern)}/  # regard as a prefix\n  end\n```\n\n```ruby\n  words.each do |word|\n    next if word.empty?\n    word.size.downto(1) { |len|\n      abbrev = word[0...len]\n      next if pattern \u0026\u0026 pattern !~ abbrev\n      ...\n    }\n  end\nend\n```\n\n```ruby\n  words.each do |word|\n    next if pattern \u0026\u0026 pattern !~ word\n    table[word] = word\n  end\n  table\nend\n```\n\n---\n\n### abbrev の第 2 引数は String, Regexp 以外を考慮していない\n\n- String, Regexp 以外を考慮しておらず、たまたま `{}` を返すようになっているだけに見える\n- 実行時にエラーにならない場合はどう型をつければよいのか\n  - Integer or Object を引数に取ることを認める\n  - String と Regexp 以外は認めない\n\n---\n\n### このような場合にどうすればよいか\n\n- ドキュメントにどう書かれているか\n- エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n---\n\n### ドキュメント\n\n\u003e The optional pattern parameter is a pattern or a string.\n\u003e Only input strings that match the pattern or start with the string are included in the output hash.\n\npattern とは言っているけれど、それが Regexp とは限定していない。\n\n---\n\n### エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n何かのメソッドの返り値が String や Regexp だと思っていたのに Integer だった場合\n\n```ruby\ndef some_method: () -\u003e (String | Integer)\n\npattern = some_method()\n\nAbbrev.abbrev([\"12345\"], pattern)\n#=\u003e {}\n```\n\nInteger が来てここでエラーにならなくてもその後で不整合がおこる場合に困る。\nここを通るテストがない場合になぜ駄目なのかの調査が必要になる。\nそれよりも型検査で弾いてくれたほうが嬉しい。\n\n---\n\n### 結果\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String], ?(String | Regexp | nil)) -\u003e Hash[String, String]\nend\n\n```\n\n第 2 引数は String, Regexp, nil としました。\nこの定義で ruby-signature に PR を送ってマージされた。\n\n---\n\n## まとめ\n\n- ruby-signature の紹介\n- ドキュメントにない場合でもそれっぽく動く場合がある\n- どう動いてほしいかを考えて型をつけないといけない場合がある\n"}},"__N_SSG":true},"page":"/slides/[slug]","query":{"slug":"feeling-to-type-ruby"},"buildId":"VmuCmjWVz9JrsUnu1Nh0c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>