<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="title" content="(wat-aro)"/><meta name="description" content="wat-aro のサイト"/><meta property="og:locale" content="ja_jp"/><meta property="og:type" content="article"/><meta property="og:site_name" content="(wat-aro)"/><meta property="og:title" content="(wat-aro)"/><meta property="og:image" content="https://wat-aro.dev/images/default-ogimage.png"/><meta property="og:url" content="https://wat-aro.dev/slides/pipeline-operator"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@wat_aro"/><meta name="twitter:creator" content="@wat_aro"/><meta name="twitter:title" content="(wat-aro)"/><meta name="twitter:description" content="wat-aro のサイト"/><meta name="twitter:image" content="https://wat-aro.dev/images/default-ogimage.png"/><meta name="next-head-count" content="16"/><link rel="icon" href="/images/favicon.ico"/><link rel="preload" href="/_next/static/css/cef7709dba1aabcc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cef7709dba1aabcc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/2b5404e9d344d383.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2b5404e9d344d383.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-e7be5a2ce3007f17.js" defer=""></script><script src="/_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="/_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-847cc7a6659a518e.js" defer=""></script><script src="/_next/static/chunks/pages/slides/%5Bslug%5D-2c380248fcce344d.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_buildManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_ssgManifest.js" defer=""></script><script src="/_next/static/VmuCmjWVz9JrsUnu1Nh0c/_middlewareManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MW6D56L" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><div class="py-0 md:px-8 min-h-screen flex flex-col items-center"><div class="top-0 bg-white w-full h-16 flex flex-row justify-between items-center px-4 border-b-2"><a href="/"><div class="flex items-center font-midium text-3xl h-full font-bold gap-4"><img class="rounded-full" src="/images/profile.jpg" width="48" height="48" alt="profile image"/>(wat-aro)<!-- --></div></a><ul class="flex gap-3 h-full"><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/posts">Blog</a></li><li class="h-full flex flex-col justify-end border-black pb-3 border-b-4"><a href="/slides">Slide</a></li><li class="h-full flex flex-col justify-end border-black pb-4"><a href="/about">About</a></li></ul></div><div class="flex md:justify-center justify-between w-full flex-grow"><div class="flex flex-col sm:max-w-sm md:max-w-4xl w-full py-4 px-4"><div class="top-0 left-0 w-full h-full"><div class="reveal"><div class="slides">
        <section data-markdown data-separator-vertical="^===
">
          <textarea data-template>
            ## パイプライン演算子

wat-aro

---

### パイプライン演算子

こんな感じのやつ

```elm
  [1, 2, 3]
  |> List.map (\x -> x * 2)
  |> List.foldl (+)
```

---

#### パイプライン演算子

`|>` の前の値を関数に適用する

---

#### パイプライン演算子

- 元は Isabela/ML あたりが発祥
- F# が採用
- OCaml が採用
- Elixir が F# から採用
- Ruby に入りそう

---

---

### ML などにおけるパイプライン演算子のつくりかた

以下を満たせば簡単につくれる

- ユーザ定義演算子
- デフォルトでカリー化

---

#### Haskell でのつくり方

第一引数を第二引数に適用するだけ

```haskell
(|>) :: a -> (a -> b) -> b
(|>) a f = f a
```

---

---

### カリー化と部分適用

以降の話に関わるのでここでおさらい

---

#### カリー化

複数の引数を受け取る関数を一引数の関数に変換する

```haskell
uncuffyFunction :: (a, b, c) -> d
uncuffyFunction (a, b, c) = somethingToDo a b c

curriedFunction :: a -> b -> c -> d
curriedFunction a b c = somethingToDo a b c
```

---

#### ES6

```js
const uncurryFunction = (a, b, c) => somethigTodo(a, b, c);

const curriedFunction = (a) => (b) => (c) => somethingTodo(a, b, c);
```

curriedFunction は引数を一つとると残りの引数を _一つずつ取る関数_ を返す
uncurry な関数を curried な関数に変換するのが

---

### 部分適用

複数の引数を取る関数で、一部にだけ引数を適用した状態の関数を返す。

```js
const partialApplied = somethigTodo(1, 2, ?);
```

---

### なぜカリー化と部分適用の話を？

Elixir などのデフォルトでカリー化されていない言語では関数のようにパイプライン演算子を定義できない
e.g.

- Elixir, Clojure はマクロ
- Ruby は言語組み込みの機構

---

---

### Elixir のパイプライン演算子

ML 系は関数の最後の引数に値を差し込む
Elixir は最初の引数を差し込む

---

#### Elixir の |>

```elixir
[1, [[2], 3]]
  |> List.flatten
  |> Enum.map(fn x -> x * x end)
  |> Enum.reduce(0, fn(x, acc) -> x + acc end)
```

---

#### Elixir の |>

カリー化されていないため AST を変換する必要がある

---

---

### Ruby のパイプライン演算子

パイプラインといいつつただの優先度の低い `.`

---

#### Ruby のパイプライン演算子

```ruby
(1..5).map {|x| x * 2 }

1..5 |> map {|x| x * 2 }
```

のように書ける

---

---

#### Ruby のパイプライン演算子における応用

[![Image from Gyazo](https://i.gyazo.com/4ecb8454c6bfc9d8470cb6c118129d21.png)](https://twitter.com/hanachin_/status/1139406434846695430)()

これの話をしたかった

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
```

`.:` は Ruby 2.7 で入る演算子。
Method オブジェクトを取り出す。
Method オブジェクトはほぼ Proc オブジェクトと同じふるまい。
詳しくはドキュメントを読んでください。

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
```

`URI.parse` でなく `URI.:parse` に注意。
とりだした Method オブジェクトを `|>` と `>>` で合成する。
`>>` は Ruby2.6 で入った関数(Proc)合成演算子。
`URI.:parse` で `URI.parse` の Method オブジェクトを取りだし、
`>>` によって合成している。
つまり

```ruby
URI.parse("https://api.github.com/repos/ruby/ruby ")
```

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
  |>>> Net::HTTP.:get
```

`Net::HTTP.:get` で `Net:HTTP.get` の Method オブジェクトを取り出す。

```ruby
uri = URI.parse("https://api.github.com/repos/ruby/ruby ")
Net::HTTP.get(uri)
```

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
  |>>> Net::HTTP.:get
  |>>> JSON.:parse
```

ここでも `JSON.:parse` で `JSON.parse` で Method オブジェクトを取り出す

```ruby
uri = URI.parse("https://api.github.com/repos/ruby/ruby ")
response = Net::HTTP.get(uri)
JSON.parse(response)
```

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
  |>>> Net::HTTP.:get
  |>>> JSON.:parse
  |> call
```

今までは Method オブジェクトを合成しただけなので、ここでやっと評価され、値になる。

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
  |>>> Net::HTTP.:get
  |>>> JSON.:parse
  |> call
  |> fetch("stargazers_count")
```

`Hash#fetch` で値を取りだす

---

#### Ruby のパイプライン演算子における応用

```ruby
"https://api.github.com/repos/ruby/ruby ".:itself
  |>>> URI.:parse
  |>>> Net::HTTP.:get
  |>>> JSON.:parse
  |> call
  |> fetch("stargazers_count")
  |> then { puts @1 }
```

そして標準出力へ。
`@1` は Ruby2.7 で入る予定。

```ruby
"hoge".then { puts @1 }
"hoge".then {|s| puts s }
```

---

#### Ruby のパイプライン演算子における応用

たーのしー

---

---

### まとめ

パイプライン演算子の説明
Ruby2.7 で入る予定のパイプライン演算子とその応用の紹介
関数合成をキメていこう

---

#### 悲しみ

[![Image from Gyazo](https://i.gyazo.com/47e87c4f7f7ad60bb2f657b4ebbf431b.png)](https://twitter.com/hanachin_/status/1139406434846695430)

---

もっと詳しく知りたい人は

[パイプライン演算子の歴史 - まめめも](https://mametter.hatenablog.com/entry/2019/06/15/192311)
[第一引数版パイプライン演算子 - Qiita @cedretaber](https://qiita.com/cedretaber/items/6a3831367439f64756ab)

          </textarea>
        </section>
    </div></div></div></div></div><div class="flex md:justify-center w-full"><div class="flex flex-col md:max-w-4xl w-full"><hr/><div class="flex justify-center pt-4 pb-8">© 2022 wat-aro</div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"slide":{"title":"パイプライン演算子","published":"2019/06/20","tags":["Functional Programming","Ruby"],"slug":"pipeline-operator","content":"## パイプライン演算子\n\nwat-aro\n\n---\n\n### パイプライン演算子\n\nこんな感じのやつ\n\n```elm\n  [1, 2, 3]\n  |\u003e List.map (\\x -\u003e x * 2)\n  |\u003e List.foldl (+)\n```\n\n---\n\n#### パイプライン演算子\n\n`|\u003e` の前の値を関数に適用する\n\n---\n\n#### パイプライン演算子\n\n- 元は Isabela/ML あたりが発祥\n- F# が採用\n- OCaml が採用\n- Elixir が F# から採用\n- Ruby に入りそう\n\n---\n\n---\n\n### ML などにおけるパイプライン演算子のつくりかた\n\n以下を満たせば簡単につくれる\n\n- ユーザ定義演算子\n- デフォルトでカリー化\n\n---\n\n#### Haskell でのつくり方\n\n第一引数を第二引数に適用するだけ\n\n```haskell\n(|\u003e) :: a -\u003e (a -\u003e b) -\u003e b\n(|\u003e) a f = f a\n```\n\n---\n\n---\n\n### カリー化と部分適用\n\n以降の話に関わるのでここでおさらい\n\n---\n\n#### カリー化\n\n複数の引数を受け取る関数を一引数の関数に変換する\n\n```haskell\nuncuffyFunction :: (a, b, c) -\u003e d\nuncuffyFunction (a, b, c) = somethingToDo a b c\n\ncurriedFunction :: a -\u003e b -\u003e c -\u003e d\ncurriedFunction a b c = somethingToDo a b c\n```\n\n---\n\n#### ES6\n\n```js\nconst uncurryFunction = (a, b, c) =\u003e somethigTodo(a, b, c);\n\nconst curriedFunction = (a) =\u003e (b) =\u003e (c) =\u003e somethingTodo(a, b, c);\n```\n\ncurriedFunction は引数を一つとると残りの引数を _一つずつ取る関数_ を返す\nuncurry な関数を curried な関数に変換するのが\n\n---\n\n### 部分適用\n\n複数の引数を取る関数で、一部にだけ引数を適用した状態の関数を返す。\n\n```js\nconst partialApplied = somethigTodo(1, 2, ?);\n```\n\n---\n\n### なぜカリー化と部分適用の話を？\n\nElixir などのデフォルトでカリー化されていない言語では関数のようにパイプライン演算子を定義できない\ne.g.\n\n- Elixir, Clojure はマクロ\n- Ruby は言語組み込みの機構\n\n---\n\n---\n\n### Elixir のパイプライン演算子\n\nML 系は関数の最後の引数に値を差し込む\nElixir は最初の引数を差し込む\n\n---\n\n#### Elixir の |\u003e\n\n```elixir\n[1, [[2], 3]]\n  |\u003e List.flatten\n  |\u003e Enum.map(fn x -\u003e x * x end)\n  |\u003e Enum.reduce(0, fn(x, acc) -\u003e x + acc end)\n```\n\n---\n\n#### Elixir の |\u003e\n\nカリー化されていないため AST を変換する必要がある\n\n---\n\n---\n\n### Ruby のパイプライン演算子\n\nパイプラインといいつつただの優先度の低い `.`\n\n---\n\n#### Ruby のパイプライン演算子\n\n```ruby\n(1..5).map {|x| x * 2 }\n\n1..5 |\u003e map {|x| x * 2 }\n```\n\nのように書ける\n\n---\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n[![Image from Gyazo](https://i.gyazo.com/4ecb8454c6bfc9d8470cb6c118129d21.png)](https://twitter.com/hanachin_/status/1139406434846695430)()\n\nこれの話をしたかった\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n```\n\n`.:` は Ruby 2.7 で入る演算子。\nMethod オブジェクトを取り出す。\nMethod オブジェクトはほぼ Proc オブジェクトと同じふるまい。\n詳しくはドキュメントを読んでください。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n```\n\n`URI.parse` でなく `URI.:parse` に注意。\nとりだした Method オブジェクトを `|\u003e` と `\u003e\u003e` で合成する。\n`\u003e\u003e` は Ruby2.6 で入った関数(Proc)合成演算子。\n`URI.:parse` で `URI.parse` の Method オブジェクトを取りだし、\n`\u003e\u003e` によって合成している。\nつまり\n\n```ruby\nURI.parse(\"https://api.github.com/repos/ruby/ruby \")\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n```\n\n`Net::HTTP.:get` で `Net:HTTP.get` の Method オブジェクトを取り出す。\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nNet::HTTP.get(uri)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n```\n\nここでも `JSON.:parse` で `JSON.parse` で Method オブジェクトを取り出す\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nresponse = Net::HTTP.get(uri)\nJSON.parse(response)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n```\n\n今までは Method オブジェクトを合成しただけなので、ここでやっと評価され、値になる。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n  |\u003e fetch(\"stargazers_count\")\n```\n\n`Hash#fetch` で値を取りだす\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |\u003e\u003e\u003e URI.:parse\n  |\u003e\u003e\u003e Net::HTTP.:get\n  |\u003e\u003e\u003e JSON.:parse\n  |\u003e call\n  |\u003e fetch(\"stargazers_count\")\n  |\u003e then { puts @1 }\n```\n\nそして標準出力へ。\n`@1` は Ruby2.7 で入る予定。\n\n```ruby\n\"hoge\".then { puts @1 }\n\"hoge\".then {|s| puts s }\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\nたーのしー\n\n---\n\n---\n\n### まとめ\n\nパイプライン演算子の説明\nRuby2.7 で入る予定のパイプライン演算子とその応用の紹介\n関数合成をキメていこう\n\n---\n\n#### 悲しみ\n\n[![Image from Gyazo](https://i.gyazo.com/47e87c4f7f7ad60bb2f657b4ebbf431b.png)](https://twitter.com/hanachin_/status/1139406434846695430)\n\n---\n\nもっと詳しく知りたい人は\n\n[パイプライン演算子の歴史 - まめめも](https://mametter.hatenablog.com/entry/2019/06/15/192311)\n[第一引数版パイプライン演算子 - Qiita @cedretaber](https://qiita.com/cedretaber/items/6a3831367439f64756ab)\n"}},"__N_SSG":true},"page":"/slides/[slug]","query":{"slug":"pipeline-operator"},"buildId":"VmuCmjWVz9JrsUnu1Nh0c","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>