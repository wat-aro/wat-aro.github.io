{"pageProps":{"title":"プログラミング Coq (証明駆動開発 2)","published":"2017/05/11","content":"<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html\">証明駆動開発入門(2)</a></p>\n<p>上記ページの勉強メモです。</p>\n<h1 id=\"extraction\">Extraction</h1>\n<p>coq から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> のコードを出力する。<br></p>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> にコードを出力するにはそのまま<br></p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction map.</span></code></pre>\n<p>とすればいい。<br>\nこれで</p>\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\"><span class=\"synComment\">(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> <span class=\"synConstant\">Nil</span> <span class=\"synStatement\">-></span> <span class=\"synConstant\">Nil</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">(</span>a, t<span class=\"synStatement\">)</span> <span class=\"synStatement\">-></span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">((</span>f a<span class=\"synStatement\">)</span>, <span class=\"synStatement\">(</span>map f t<span class=\"synStatement\">))</span>\n</span></code></pre>\n<p>と出力される。（proof-general を使っています。coq-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a>の場合はcommand pane で実行）<br></p>\n<p>この時、list が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストでなく coq で定義された list になっている。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使うには<br></p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extract Inductive list => \"list\" [\"[]\" \"(::)\"].</span></code></pre>\n<p>を実行する。こうすると<br></p>\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\"><span class=\"synComment\">(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-></span> <span class=\"synConstant\">[]</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> a<span class=\"synStatement\">::</span>t <span class=\"synStatement\">-></span> <span class=\"synStatement\">(</span>f a<span class=\"synStatement\">)::(</span>map f t<span class=\"synStatement\">)</span>\n</span></code></pre>\n<p>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使ったmap関数が生成される。<br></p>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>  や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> に出力するにはそれぞれ<br>\n<code>Extraction Language Haskell.</code> <code>Extraction Language Scheme.</code> としてから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合と同じように出力する。<br></p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Haskell.\n</span><span class=\"code-line\">Extract Inductive list => \"list\" [\"[]\" \"(::)\"].\n</span><span class=\"code-line\">Extraction map.</span></code></pre>\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">map <span class=\"synStatement\">::</span> (a1 <span class=\"synStatement\">-></span> a2) <span class=\"synStatement\">-></span> (list a1) <span class=\"synStatement\">-></span> list a2\n</span><span class=\"code-line\">map f l <span class=\"synStatement\">=</span>\n</span><span class=\"code-line\">  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n</span><span class=\"code-line\">   [] <span class=\"synStatement\">-></span> [];\n</span><span class=\"code-line\">   (<span class=\"synStatement\">::</span>) a t <span class=\"synStatement\">-></span> (<span class=\"synStatement\">::</span>) (f a) (map f t)}\n</span></code></pre>\n<p>正しいけど、あまり綺麗なコードじゃない。<br></p>\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">map <span class=\"synStatement\">::</span> (a <span class=\"synStatement\">-></span> b) <span class=\"synStatement\">-></span> (list a) <span class=\"synStatement\">-></span> list b\n</span><span class=\"code-line\">map f [] <span class=\"synStatement\">=</span> []\n</span><span class=\"code-line\">map f x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">=</span> (f x) <span class=\"synStatement\">::</span> (map f xs)\n</span></code></pre>\n<p>くらいには変換してほしいけど、元の形からすると厳しいのかな。<br></p>\n<p>次は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/scheme\">scheme</a>.<br></p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Scheme.\n</span><span class=\"code-line\">Extraction map.</span></code></pre>\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\"><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> <span class=\"synIdentifier\">map</span> <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>f l<span class=\"synSpecial\">)</span>\n</span><span class=\"code-line\">  <span class=\"synSpecial\">(</span>match l\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> a t<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,(</span>f a<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">,(</span>@ <span class=\"synIdentifier\">map</span> f t<span class=\"synSpecial\">))))))</span>\n</span></code></pre>\n<p>おお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、<code>,</code>使った式展開も入ってる。<br>\nCoq Extension <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。<br>\nlambdas マクロと @マクロはなかなかよい。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> っぽく書きたい時は便利そう。<br>\nmatch マクロは define-syntax みたいな感じかな？<br>\n直接変換するならたしかにこういうマクロ欲しくなるな。<br></p>\n<h2 id=\"insertion_sort-の変換\">insertion_sort の変換</h2>\n<h3 id=\"ocamlの場合\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合</h3>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Ocaml.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Extract Inductive list => \"list\" [\"[]\" \"(::)\"].\n</span><span class=\"code-line\">Extract Inductive bool => \"bool\" [\"true\" \"false\"].\n</span><span class=\"code-line\">Extract Inductive nat => int [\"0\" \"succ\"] \"(fun fO fS n -> if n = 0 then f O () else fS (n-1))\".\n</span><span class=\"code-line\">Extraction insert.\n</span><span class=\"code-line\">Extraction insertion_sort.</span></code></pre>\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\"><span class=\"synComment\">(** val insert : int -> int list -> int list **)</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insert a l <span class=\"synStatement\">=</span> <span class=\"synStatement\">match</span> l <span class=\"synStatement\">with</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-></span> a<span class=\"synStatement\">::</span><span class=\"synConstant\">[]</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-></span> <span class=\"synStatement\">if</span> <span class=\"synPreProc\">Nat</span>.leb a x <span class=\"synStatement\">then</span> a<span class=\"synStatement\">::</span>l <span class=\"synStatement\">else</span> x<span class=\"synStatement\">::(</span>insert a xs<span class=\"synStatement\">)</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synComment\">(** val insertion_sort : int list -> int list **)</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insertion_sort <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-></span> <span class=\"synConstant\">[]</span>\n</span><span class=\"code-line\"><span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-></span> insert x <span class=\"synStatement\">(</span>insertion_sort xs<span class=\"synStatement\">)</span>\n</span></code></pre>\n<h3 id=\"haskellの場合\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の場合</h3>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Haskell.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Extract Inductive list => \"([])\" [\"[]\" \"(:)\"].\n</span><span class=\"code-line\">Extract Inductive bool => \"Bool\" [\"True\" \"False\"].\n</span><span class=\"code-line\">Extract Inductive nat => Int [\"0\" \"succ\"] \"(\\fO fS n -> if n == 0 then fO () else fS (n-1))\".</span></code></pre>\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">insert <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-></span> (([]) Int) <span class=\"synStatement\">-></span> ([]) Int\n</span><span class=\"code-line\">insert a l <span class=\"synStatement\">=</span>\n</span><span class=\"code-line\">  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n</span><span class=\"code-line\">   [] <span class=\"synStatement\">-></span> (<span class=\"synStatement\">:</span>) a [];\n</span><span class=\"code-line\">   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-></span>\n</span><span class=\"code-line\">    <span class=\"synStatement\">case</span> leb a x <span class=\"synStatement\">of</span> {\n</span><span class=\"code-line\">     True <span class=\"synStatement\">-></span> (<span class=\"synStatement\">:</span>) a l;\n</span><span class=\"code-line\">     False <span class=\"synStatement\">-></span> (<span class=\"synStatement\">:</span>) x (insert a xs)}}\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">insertion_sort <span class=\"synStatement\">::</span> (([]) Int) <span class=\"synStatement\">-></span> ([]) Int\n</span><span class=\"code-line\">insertion_sort l <span class=\"synStatement\">=</span>\n</span><span class=\"code-line\">  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n</span><span class=\"code-line\">   [] <span class=\"synStatement\">-></span> [];\n</span><span class=\"code-line\">   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-></span> insert x (insertion_sort xs)}\n</span></code></pre>\n<h2 id=\"schemeの場合\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>の場合</h2>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Scheme.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Extraction insert.\n</span><span class=\"code-line\">Extraction insertion_sort.</span></code></pre>\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\"><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insert <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>a l<span class=\"synSpecial\">)</span>\n</span><span class=\"code-line\">  <span class=\"synSpecial\">(</span>match l\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,`(</span>Nil<span class=\"synSpecial\">)))</span>\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span>\n</span><span class=\"code-line\">       <span class=\"synSpecial\">(</span>match <span class=\"synSpecial\">(</span>@ leb a x<span class=\"synSpecial\">)</span>\n</span><span class=\"code-line\">          <span class=\"synSpecial\">((</span>True<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,</span>l<span class=\"synSpecial\">))</span>\n</span><span class=\"code-line\">          <span class=\"synSpecial\">((</span>False<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>x <span class=\"synSpecial\">,(</span>@ insert a xs<span class=\"synSpecial\">))))))))</span>\n</span><span class=\"code-line\">\n</span><span class=\"code-line\"><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insertion_sort <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span> <span class=\"synSpecial\">(</span>l<span class=\"synSpecial\">)</span>\n</span><span class=\"code-line\">  <span class=\"synSpecial\">(</span>match l\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n</span><span class=\"code-line\">     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">(</span>@ insert x <span class=\"synSpecial\">(</span>insertion_sort xs<span class=\"synSpecial\">))))))</span>\n</span></code></pre>\n<h2 id=\"ファイルへの出力\">ファイルへの出力</h2>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Extraction Language Ocaml.\n</span><span class=\"code-line\">Extraction \"insertion_sort.ml\" insertion_sort.</span></code></pre>\n<p>と入力して proof-general で C-c C-n すると以下のようなファイルが生成された。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">module Nat =\n</span><span class=\"code-line\"> struct\n</span><span class=\"code-line\">  (** val leb : Int -> Int -> Bool **)\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  let rec leb n m =\n</span><span class=\"code-line\">    (\\fO fS n -> if n == 0 then fO () else fS (n-1))\n</span><span class=\"code-line\">      (fun _ ->\n</span><span class=\"code-line\">      True)\n</span><span class=\"code-line\">      (fun n' ->\n</span><span class=\"code-line\">      (\\fO fS n -> if n == 0 then fO () else fS (n-1))\n</span><span class=\"code-line\">        (fun _ ->\n</span><span class=\"code-line\">        False)\n</span><span class=\"code-line\">        (fun m' ->\n</span><span class=\"code-line\">        leb n' m')\n</span><span class=\"code-line\">        m)\n</span><span class=\"code-line\">      n\n</span><span class=\"code-line\"> end\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">(** val insert : Int -> Int ([]) -> Int ([]) **)\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">let rec insert a l = match l with\n</span><span class=\"code-line\">| [] -> a:[]\n</span><span class=\"code-line\">| x:xs ->\n</span><span class=\"code-line\">  (match Nat.leb a x with\n</span><span class=\"code-line\">   | True -> a:l\n</span><span class=\"code-line\">   | False -> x:(insert a xs))\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">(** val insertion_sort : Int ([]) -> Int ([]) **)\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">let rec insertion_sort = function\n</span><span class=\"code-line\">| [] -> []\n</span><span class=\"code-line\">| x:xs -> insert x (insertion_sort xs)</span></code></pre>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">module Nat :\n</span><span class=\"code-line\"> sig\n</span><span class=\"code-line\">  val leb : Int -> Int -> Bool\n</span><span class=\"code-line\"> end\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">val insert : Int -> Int ([]) -> Int ([])\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">val insertion_sort : Int ([]) -> Int ([])</span></code></pre>\n<p>lebも作ってくれるのか。\nまあないとコードにならないもんな。</p>\n<h2 id=\"証明駆動開発のステップ\">証明駆動開発のステップ</h2>\n<ol>\n<li>まず書こうとしているプログラムがどういう性質をみたすべきかを記述し、</li>\n<li>Coq でそれをみたすようなプログラムを書き、</li>\n<li>実際に最初に考えた性質を証明し、</li>\n<li>Extraction して他の言語のコードに変換する</li>\n</ol>\n<h2 id=\"感想\">感想</h2>\n<p>形式証明が慣れてないからなのかとても難しかった。<br>\nただ、証明のステップを追うのはとても気持ちよかった。<br></p>\n<p>次は、最近発売された純粋関数型データ構造読むかなって気分。<br>\nSML で書かれているらしいから、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> に置き換えながら写経するのが楽かな？<br>\nそれとも付録に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> 実装があるらしいので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> に置き換えながら写経して、書けたら答え合わせするほうがいいかな。<br>\n悩ましい。</p>","slug":"プログラミング Coq (証明駆動開発 2)","rawContent":"\n<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html\">&#x8A3C;&#x660E;&#x99C6;&#x52D5;&#x958B;&#x767A;&#x5165;&#x9580;(2)</a></p>\n\n<p>上記ページの勉強メモです。</p>\n\n<h1>Extraction</h1>\n\n<p>coq から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> のコードを出力する。<br></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> にコードを出力するにはそのまま<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction map.</pre>\n\n\n<p>とすればいい。<br>\nこれで</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val map : ('a1 -&gt; 'a2) -&gt; 'a1 list -&gt; 'a2 list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">Nil</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">Nil</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">(</span>a, t<span class=\"synStatement\">)</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">((</span>f a<span class=\"synStatement\">)</span>, <span class=\"synStatement\">(</span>map f t<span class=\"synStatement\">))</span>\n</pre>\n\n\n<p>と出力される。（proof-general を使っています。coq-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a>の場合はcommand pane で実行）<br></p>\n\n<p>この時、list が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストでなく coq で定義された list になっている。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使うには<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].</pre>\n\n\n<p>を実行する。こうすると<br></p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val map : ('a1 -&gt; 'a2) -&gt; 'a1 list -&gt; 'a2 list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> a<span class=\"synStatement\">::</span>t <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">(</span>f a<span class=\"synStatement\">)::(</span>map f t<span class=\"synStatement\">)</span>\n</pre>\n\n\n<p>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使ったmap関数が生成される。<br></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>  や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> に出力するにはそれぞれ<br>\n<code>Extraction Language Haskell.</code> <code>Extraction Language Scheme.</code> としてから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合と同じように出力する。<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Haskell.\nExtract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].\nExtraction map.</pre>\n\n\n\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>map <span class=\"synStatement\">::</span> (a1 <span class=\"synStatement\">-&gt;</span> a2) <span class=\"synStatement\">-&gt;</span> (list a1) <span class=\"synStatement\">-&gt;</span> list a2\nmap f l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> [];\n   (<span class=\"synStatement\">::</span>) a t <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">::</span>) (f a) (map f t)}\n</pre>\n\n\n<p>正しいけど、あまり綺麗なコードじゃない。<br></p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>map <span class=\"synStatement\">::</span> (a <span class=\"synStatement\">-&gt;</span> b) <span class=\"synStatement\">-&gt;</span> (list a) <span class=\"synStatement\">-&gt;</span> list b\nmap f [] <span class=\"synStatement\">=</span> []\nmap f x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">=</span> (f x) <span class=\"synStatement\">::</span> (map f xs)\n</pre>\n\n\n<p>くらいには変換してほしいけど、元の形からすると厳しいのかな。<br></p>\n\n<p>次は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/scheme\">scheme</a>.<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Scheme.\nExtraction map.</pre>\n\n\n\n\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> <span class=\"synIdentifier\">map</span> <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>f l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> a t<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,(</span>f a<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">,(</span>@ <span class=\"synIdentifier\">map</span> f t<span class=\"synSpecial\">))))))</span>\n</pre>\n\n\n<p>おお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、<code>,</code>使った式展開も入ってる。<br>\nCoq Extension <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。<br>\nlambdas マクロと @マクロはなかなかよい。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> っぽく書きたい時は便利そう。<br>\nmatch マクロは define-syntax みたいな感じかな？<br>\n直接変換するならたしかにこういうマクロ欲しくなるな。<br></p>\n\n<h2>insertion_sort の変換</h2>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Ocaml.\n\nExtract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].\nExtract Inductive bool =&gt; &#34;bool&#34; [&#34;true&#34; &#34;false&#34;].\nExtract Inductive nat =&gt; int [&#34;0&#34; &#34;succ&#34;] &#34;(fun fO fS n -&gt; if n = 0 then f O () else fS (n-1))&#34;.\nExtraction insert.\nExtraction insertion_sort.</pre>\n\n\n\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val insert : int -&gt; int list -&gt; int list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insert a l <span class=\"synStatement\">=</span> <span class=\"synStatement\">match</span> l <span class=\"synStatement\">with</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> a<span class=\"synStatement\">::</span><span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">if</span> <span class=\"synPreProc\">Nat</span>.leb a x <span class=\"synStatement\">then</span> a<span class=\"synStatement\">::</span>l <span class=\"synStatement\">else</span> x<span class=\"synStatement\">::(</span>insert a xs<span class=\"synStatement\">)</span>\n\n<span class=\"synComment\">(** val insertion_sort : int list -&gt; int list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insertion_sort <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-&gt;</span> insert x <span class=\"synStatement\">(</span>insertion_sort xs<span class=\"synStatement\">)</span>\n</pre>\n\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の場合</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Haskell.\n\nExtract Inductive list =&gt; &#34;([])&#34; [&#34;[]&#34; &#34;(:)&#34;].\nExtract Inductive bool =&gt; &#34;Bool&#34; [&#34;True&#34; &#34;False&#34;].\nExtract Inductive nat =&gt; Int [&#34;0&#34; &#34;succ&#34;] &#34;(\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))&#34;.</pre>\n\n\n\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>insert <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&gt;</span> (([]) Int) <span class=\"synStatement\">-&gt;</span> ([]) Int\ninsert a l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) a [];\n   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-&gt;</span>\n    <span class=\"synStatement\">case</span> leb a x <span class=\"synStatement\">of</span> {\n     True <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) a l;\n     False <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) x (insert a xs)}}\n\ninsertion_sort <span class=\"synStatement\">::</span> (([]) Int) <span class=\"synStatement\">-&gt;</span> ([]) Int\ninsertion_sort l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> [];\n   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-&gt;</span> insert x (insertion_sort xs)}\n</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Scheme.\n\nExtraction insert.\nExtraction insertion_sort.</pre>\n\n\n\n\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insert <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>a l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,`(</span>Nil<span class=\"synSpecial\">)))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span>\n       <span class=\"synSpecial\">(</span>match <span class=\"synSpecial\">(</span>@ leb a x<span class=\"synSpecial\">)</span>\n          <span class=\"synSpecial\">((</span>True<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,</span>l<span class=\"synSpecial\">))</span>\n          <span class=\"synSpecial\">((</span>False<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>x <span class=\"synSpecial\">,(</span>@ insert a xs<span class=\"synSpecial\">))))))))</span>\n\n<span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insertion_sort <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span> <span class=\"synSpecial\">(</span>l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">(</span>@ insert x <span class=\"synSpecial\">(</span>insertion_sort xs<span class=\"synSpecial\">))))))</span>\n</pre>\n\n\n<h2>ファイルへの出力</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Ocaml.\nExtraction &#34;insertion_sort.ml&#34; insertion_sort.</pre>\n\n\n<p>と入力して proof-general で C-c C-n すると以下のようなファイルが生成された。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Nat =\n struct\n  (** val leb : Int -&gt; Int -&gt; Bool **)\n\n  let rec leb n m =\n    (\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))\n      (fun _ -&gt;\n      True)\n      (fun n&#39; -&gt;\n      (\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))\n        (fun _ -&gt;\n        False)\n        (fun m&#39; -&gt;\n        leb n&#39; m&#39;)\n        m)\n      n\n end\n\n(** val insert : Int -&gt; Int ([]) -&gt; Int ([]) **)\n\nlet rec insert a l = match l with\n| [] -&gt; a:[]\n| x:xs -&gt;\n  (match Nat.leb a x with\n   | True -&gt; a:l\n   | False -&gt; x:(insert a xs))\n\n(** val insertion_sort : Int ([]) -&gt; Int ([]) **)\n\nlet rec insertion_sort = function\n| [] -&gt; []\n| x:xs -&gt; insert x (insertion_sort xs)</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Nat :\n sig\n  val leb : Int -&gt; Int -&gt; Bool\n end\n\nval insert : Int -&gt; Int ([]) -&gt; Int ([])\n\nval insertion_sort : Int ([]) -&gt; Int ([])</pre>\n\n\n<p>lebも作ってくれるのか。\nまあないとコードにならないもんな。</p>\n\n<h2>証明駆動開発のステップ</h2>\n\n<ol>\n<li>まず書こうとしているプログラムがどういう性質をみたすべきかを記述し、</li>\n<li>Coq でそれをみたすようなプログラムを書き、</li>\n<li>実際に最初に考えた性質を証明し、</li>\n<li>Extraction して他の言語のコードに変換する</li>\n</ol>\n\n\n<h2>感想</h2>\n\n<p>形式証明が慣れてないからなのかとても難しかった。<br>\nただ、証明のステップを追うのはとても気持ちよかった。<br></p>\n\n<p>次は、最近発売された純粋関数型データ構造読むかなって気分。<br>\nSML で書かれているらしいから、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> に置き換えながら写経するのが楽かな？<br>\nそれとも付録に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> 実装があるらしいので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> に置き換えながら写経して、書けたら答え合わせするほうがいいかな。<br>\n悩ましい。</p>\n\n"},"__N_SSG":true}