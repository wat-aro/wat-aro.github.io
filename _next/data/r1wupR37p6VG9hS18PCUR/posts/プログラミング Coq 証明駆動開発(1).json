{"pageProps":{"title":"プログラミング Coq 証明駆動開発(1)","published":"2017/05/11","content":"<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html\">証明駆動開発入門(1)</a></p>\n<p><code>何かを読む会</code> という社内勉強会が発足されました。\n読んだ本の内容を共有しよう。\n一人で勉強していてもダレるので共有することで無理やり進捗を出そう。\n他の人の発表を聞いて読んだ気になろう。\nっていう緩めの会です。\n途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。</p>\n<h1 id=\"挿入ソートを証明する\">挿入ソートを証明する。</h1>\n<p>証明したいことは次の二点。</p>\n<ul>\n<li>挿入前と挿入後で要素に変化がないこと(isort_permutation)</li>\n<li>挿入後に要素が整列されていること(isort_sorted)</li>\n</ul>\n<p>上記を型で示すと以下のようになる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">isort_permutation : forall (l : list nat), Permutation l (insertion_sort l)\n</span><span class=\"code-line\">isort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)</span></code></pre>\n<h2 id=\"実装\">実装</h2>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Require Import List.\n</span><span class=\"code-line\">Require Import Arith.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Fixpoint insert (a : nat) (l : list nat) : list nat :=\n</span><span class=\"code-line\">  match l with\n</span><span class=\"code-line\">  | nil => a :: nil\n</span><span class=\"code-line\">  | x :: xs => if leb a x then a :: l else x :: insert a xs\n</span><span class=\"code-line\">  end.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Fixpoint insertion_sort (l : list nat) : list nat :=\n</span><span class=\"code-line\">  match l with\n</span><span class=\"code-line\">  | nil => nil\n</span><span class=\"code-line\">  | x :: xs => insert x (insertion_sort xs)\n</span><span class=\"code-line\">  end.</span></code></pre>\n<h2 id=\"要素の変化がないこと\">要素の変化がないこと</h2>\n<p>あるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Inductive Permutation : list A -> list A -> Prop :=\n</span><span class=\"code-line\">  | perm_nil: Permutation [] []\n</span><span class=\"code-line\">  | perm_skip x l l' : Permutation l l' -> Permutation (x::l) (x::l')\n</span><span class=\"code-line\">  | perm_swap x y l : Permutation (y::x::l) (x::y::l)\n</span><span class=\"code-line\">  | perm_trans l l' l'' : Permutation l l' -> Permutation l' l'' -> Permutation l l''.</span></code></pre>\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は同じ要素から成り立つ</li>\n<li>l と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ</li>\n<li>y :: x :: l と x :: y :: l は同じ要素から成り立つ</li>\n<li>(l と l' が同じ要素から成り立ち、l' と l'‘ が同じ要素から成り立つ) ならば l と l’‘ も同じ要素から成り立つ</li>\n</ol>\n<h2 id=\"isort_permutation-の証明\">isort_permutation の証明</h2>\n<p>isort_permutation の型</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : list nat), Permutation l (insertion_sort l)</span></code></pre>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を使う。\nl が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の時は insertion_sort l は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> なので\nPermutation <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり自明。</p>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>のため、nの場合にあたる仮定は</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : list nat), Permutation xs (insertion_sort xs)</span></code></pre>\n<p>n + 1 に当たる命題は</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : list nat), Permutation x :: xs (insertion_sort x::xs)</span></code></pre>\n<p>となり、</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)</span></code></pre>\n<p>と変形できる。</p>\n<p>つまり</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)</span></code></pre>\n<p>と</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)</span></code></pre>\n<p>を示すことで perm_trans から</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">forall l l' l'' , Permutation l l' -> Permutation l' l'' -> Permutation l l''</span></code></pre>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Permutation (x :: xs) (x :: insertion_sort xs) ->\n</span><span class=\"code-line\">  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) ->\n</span><span class=\"code-line\">    Permutation (x :: xs) (insert x (insertion_sort xs))</span></code></pre>\n<p>となり、導ける。</p>\n<p>A  については 仮定と Permutation のコンストラクタ</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">perm_skip : forall x l l', Permutation l l' -> Permutation (x :: l) (x :: l')</span></code></pre>\n<p>から導ける。</p>\n<p>まず B を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明する。</p>\n<p>isort_permutaiton の証明は以下。</p>\n<table>\n<thead>\n<tr>\n<th> 命令 </th>\n<th> 説明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> intros </td>\n<td> forall などから変数を仮定へ移動する </td>\n</tr>\n<tr>\n<td> simpl </td>\n<td> 簡約 </td>\n</tr>\n<tr>\n<td> apply </td>\n<td> 仮定や定理などを適用 </td>\n</tr>\n<tr>\n<td> destruct </td>\n<td> 条件分岐しているものなどを subgoal に分ける </td>\n</tr>\n<tr>\n<td> induction </td>\n<td> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を実施するために subgoal に分ける </td>\n</tr>\n</tbody>\n</table>\n<p>どういうふうに証明が進むかは coq <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a> や proof-general 使って見てください。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Require Import List.\n</span><span class=\"code-line\">Require Import Arith.\n</span><span class=\"code-line\">Require Import Sorting.Permutation.\n</span><span class=\"code-line\">Require Import Sorting.Sorted.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">(* isort_permutation *)\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Lemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).\n</span><span class=\"code-line\">  induction l.\n</span><span class=\"code-line\">  intros.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  apply Permutation_refl.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  intros.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  destruct (leb x a).\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply Permutation_refl.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply perm_trans with (a :: x :: l).\n</span><span class=\"code-line\">  apply perm_swap.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply perm_skip.\n</span><span class=\"code-line\">  apply IHl.\n</span><span class=\"code-line\">Qed.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">Theorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).\n</span><span class=\"code-line\">  induction l.\n</span><span class=\"code-line\">  apply perm_nil.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  apply perm_trans with (a :: insertion_sort l).\n</span><span class=\"code-line\">  apply perm_skip.\n</span><span class=\"code-line\">  apply IHl.\n</span><span class=\"code-line\">  apply insert_perm.\n</span><span class=\"code-line\">Qed.</span></code></pre>\n<h2 id=\"整列の定義\">整列の定義</h2>\n<p>リスト l が整列されていることはSorting.Sortedモジュールで定義されている.</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Induction LocallySorted (A : Type) (R : A -> A -> Prop) : list A :=\n</span><span class=\"code-line\">  | LSorted_nil : LocallySorted R nil\n</span><span class=\"code-line\">  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)\n</span><span class=\"code-line\">  | LSorted_consn : forall (a b : A) (l : list A),\n</span><span class=\"code-line\">    LocallySorted R (b :: l) ->\n</span><span class=\"code-line\">      R a b -> LocallySorted R (a :: b :: l)</span></code></pre>\n<p>上の定義は次のような意味です。\nR a b は a &#x3C; b のようなものです。</p>\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>x :: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>b :: l が整列しているとき, R a b ならば a :: b :: l は整列している</li>\n</ol>\n<h2 id=\"整列されていることの証明\">整列されていることの証明</h2>\n<p>こちらでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>で考える。\nまず l が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の場合は insertion_sort <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり、LSorted_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> : LocallySorted le <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> から明らか。</p>\n<p>LocallySort le (insertion_sort l) -> LocallySort le (insertion_sort (a :: l)) の場合を考える。\nLocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。\nこの時、insertion_sort l は仮定より整列しているため、</p>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">insert_sorted : forall (a : nat) (l : list a), LocallySort le l -> LocallySorted le (insert a l)</span></code></pre>\n<p>を示すことができれば証明できる。</p>\n<p>これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明をすすめる。</p>\n<h2 id=\"整列の証明\">整列の証明</h2>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Lemma insert_sorted : forall (a : nat) (l : list nat),\n</span><span class=\"code-line\">    LocallySorted le l -> LocallySorted le (insert a l).\n</span><span class=\"code-line\">  induction l.\n</span><span class=\"code-line\">  constructor.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  intro.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  remember (leb a a0).\n</span><span class=\"code-line\">  destruct b.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply LSorted_consn.\n</span><span class=\"code-line\">  apply H.\n</span><span class=\"code-line\">  apply leb_complete.\n</span><span class=\"code-line\">  congruence.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  inversion H.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  apply LSorted_consn.\n</span><span class=\"code-line\">  apply LSorted_cons1.\n</span><span class=\"code-line\">  apply lt_le_weak.\n</span><span class=\"code-line\">  apply leb_complete_conv.\n</span><span class=\"code-line\">  congruence.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  subst.\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">  simpl in IHl.\n</span><span class=\"code-line\">  remember (leb a b).\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  destruct b0.\n</span><span class=\"code-line\">  apply LSorted_consn.\n</span><span class=\"code-line\">  apply IHl.\n</span><span class=\"code-line\">  apply H2.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply lt_le_weak.\n</span><span class=\"code-line\">  apply leb_complete_conv.\n</span><span class=\"code-line\">  congruence.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply LSorted_consn.\n</span><span class=\"code-line\">  apply IHl.\n</span><span class=\"code-line\">  apply H2.\n</span><span class=\"code-line\">  apply H3.\n</span><span class=\"code-line\">Qed.</span></code></pre>\n<pre class=\"code\" data-lang=\"\" data-unlink=\"\"><code class=\"code-highlight\"><span class=\"code-line\">Theorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).\n</span><span class=\"code-line\">  induction l.\n</span><span class=\"code-line\">  constructor.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  simpl.\n</span><span class=\"code-line\">\n</span><span class=\"code-line\">  apply insert_sorted.\n</span><span class=\"code-line\">  apply IHl.\n</span><span class=\"code-line\">Qed.</span></code></pre>\n<p>これで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。</p>","slug":"プログラミング Coq 証明駆動開発(1)","rawContent":"\n<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html\">&#x8A3C;&#x660E;&#x99C6;&#x52D5;&#x958B;&#x767A;&#x5165;&#x9580;(1)</a></p>\n\n<p><code>何かを読む会</code> という社内勉強会が発足されました。\n読んだ本の内容を共有しよう。\n一人で勉強していてもダレるので共有することで無理やり進捗を出そう。\n他の人の発表を聞いて読んだ気になろう。\nっていう緩めの会です。\n途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。</p>\n\n<h1>挿入ソートを証明する。</h1>\n\n<p>証明したいことは次の二点。</p>\n\n<ul>\n<li>挿入前と挿入後で要素に変化がないこと(isort_permutation)</li>\n<li>挿入後に要素が整列されていること(isort_sorted)</li>\n</ul>\n\n\n<p>上記を型で示すと以下のようになる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>isort_permutation : forall (l : list nat), Permutation l (insertion_sort l)\nisort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)</pre>\n\n\n<h2>実装</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Require Import List.\nRequire Import Arith.\n\nFixpoint insert (a : nat) (l : list nat) : list nat :=\n  match l with\n  | nil =&gt; a :: nil\n  | x :: xs =&gt; if leb a x then a :: l else x :: insert a xs\n  end.\n\nFixpoint insertion_sort (l : list nat) : list nat :=\n  match l with\n  | nil =&gt; nil\n  | x :: xs =&gt; insert x (insertion_sort xs)\n  end.</pre>\n\n\n<h2>要素の変化がないこと</h2>\n\n<p>あるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Inductive Permutation : list A -&gt; list A -&gt; Prop :=\n  | perm_nil: Permutation [] []\n  | perm_skip x l l&#39; : Permutation l l&#39; -&gt; Permutation (x::l) (x::l&#39;)\n  | perm_swap x y l : Permutation (y::x::l) (x::y::l)\n  | perm_trans l l&#39; l&#39;&#39; : Permutation l l&#39; -&gt; Permutation l&#39; l&#39;&#39; -&gt; Permutation l l&#39;&#39;.</pre>\n\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は同じ要素から成り立つ</li>\n<li>l と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ</li>\n<li>y :: x :: l と x :: y :: l は同じ要素から成り立つ</li>\n<li>(l と l' が同じ要素から成り立ち、l' と l'&lsquo; が同じ要素から成り立つ) ならば l と l&rsquo;&lsquo; も同じ要素から成り立つ</li>\n</ol>\n\n\n<h2>isort_permutation の証明</h2>\n\n<p>isort_permutation の型</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation l (insertion_sort l)</pre>\n\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を使う。\nl が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の時は insertion_sort l は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> なので\nPermutation <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり自明。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>のため、nの場合にあたる仮定は</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation xs (insertion_sort xs)</pre>\n\n\n<p>n + 1 に当たる命題は</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation x :: xs (insertion_sort x::xs)</pre>\n\n\n<p>となり、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)</pre>\n\n\n<p>と変形できる。</p>\n\n<p>つまり</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)</pre>\n\n\n<p>と</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)</pre>\n\n\n<p>を示すことで perm_trans から</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall l l&#39; l&#39;&#39; , Permutation l l&#39; -&gt; Permutation l&#39; l&#39;&#39; -&gt; Permutation l l&#39;&#39;</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Permutation (x :: xs) (x :: insertion_sort xs) -&gt;\n  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) -&gt;\n    Permutation (x :: xs) (insert x (insertion_sort xs))</pre>\n\n\n<p>となり、導ける。</p>\n\n<p>A  については 仮定と Permutation のコンストラクタ</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>perm_skip : forall x l l&#39;, Permutation l l&#39; -&gt; Permutation (x :: l) (x :: l&#39;)</pre>\n\n\n<p>から導ける。</p>\n\n<p>まず B を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明する。</p>\n\n<p>isort_permutaiton の証明は以下。</p>\n\n<table>\n<thead>\n<tr>\n<th> 命令 </th>\n<th> 説明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> intros </td>\n<td> forall などから変数を仮定へ移動する </td>\n</tr>\n<tr>\n<td> simpl </td>\n<td> 簡約 </td>\n</tr>\n<tr>\n<td> apply </td>\n<td> 仮定や定理などを適用 </td>\n</tr>\n<tr>\n<td> destruct </td>\n<td> 条件分岐しているものなどを subgoal に分ける </td>\n</tr>\n<tr>\n<td> induction </td>\n<td> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を実施するために subgoal に分ける </td>\n</tr>\n</tbody>\n</table>\n\n\n<p>どういうふうに証明が進むかは coq <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a> や proof-general 使って見てください。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Require Import List.\nRequire Import Arith.\nRequire Import Sorting.Permutation.\nRequire Import Sorting.Sorted.\n\n(* isort_permutation *)\n\nLemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).\n  induction l.\n  intros.\n  simpl.\n  apply Permutation_refl.\n\n  intros.\n  simpl.\n  destruct (leb x a).\n\n  apply Permutation_refl.\n\n  apply perm_trans with (a :: x :: l).\n  apply perm_swap.\n\n  apply perm_skip.\n  apply IHl.\nQed.\n\nTheorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).\n  induction l.\n  apply perm_nil.\n  simpl.\n  apply perm_trans with (a :: insertion_sort l).\n  apply perm_skip.\n  apply IHl.\n  apply insert_perm.\nQed.</pre>\n\n\n<h2>整列の定義</h2>\n\n<p>リスト l が整列されていることはSorting.Sortedモジュールで定義されている.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Induction LocallySorted (A : Type) (R : A -&gt; A -&gt; Prop) : list A :=\n  | LSorted_nil : LocallySorted R nil\n  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)\n  | LSorted_consn : forall (a b : A) (l : list A),\n    LocallySorted R (b :: l) -&gt;\n      R a b -&gt; LocallySorted R (a :: b :: l)</pre>\n\n\n<p>上の定義は次のような意味です。\nR a b は a &lt; b のようなものです。</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>x :: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>b :: l が整列しているとき, R a b ならば a :: b :: l は整列している</li>\n</ol>\n\n\n<h2>整列されていることの証明</h2>\n\n<p>こちらでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>で考える。\nまず l が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の場合は insertion_sort <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり、LSorted_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> : LocallySorted le <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> から明らか。</p>\n\n<p>LocallySort le (insertion_sort l) -> LocallySort le (insertion_sort (a :: l)) の場合を考える。\nLocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。\nこの時、insertion_sort l は仮定より整列しているため、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>insert_sorted : forall (a : nat) (l : list a), LocallySort le l -&gt; LocallySorted le (insert a l)</pre>\n\n\n<p>を示すことができれば証明できる。</p>\n\n<p>これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明をすすめる。</p>\n\n<h2>整列の証明</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Lemma insert_sorted : forall (a : nat) (l : list nat),\n    LocallySorted le l -&gt; LocallySorted le (insert a l).\n  induction l.\n  constructor.\n\n  intro.\n  simpl.\n  remember (leb a a0).\n  destruct b.\n\n  apply LSorted_consn.\n  apply H.\n  apply leb_complete.\n  congruence.\n\n  inversion H.\n  simpl.\n  apply LSorted_consn.\n  apply LSorted_cons1.\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  subst.\n  simpl.\n  simpl in IHl.\n  remember (leb a b).\n\n  destruct b0.\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n  apply H3.\nQed.</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Theorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).\n  induction l.\n  constructor.\n\n  simpl.\n\n  apply insert_sorted.\n  apply IHl.\nQed.</pre>\n\n\n<p>これで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。</p>\n\n"},"__N_SSG":true}