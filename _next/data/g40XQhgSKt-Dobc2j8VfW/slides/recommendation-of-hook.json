{"pageProps":{"slide":{"title":"React Hooks のすすめ","published":"2020/10/23","tags":["JS","React"],"slug":"recommendation-of-hook","content":"# `React Hooks` のすすめ\n\n---\n\n## `About me`\n\n- wat-aro\n- @wat_aro\n- Github: wat-aro\n\n---\n\n### お仕事関係\n\n- 元陸上自衛官\n- Fjord 卒業生\n- 永和システムマネジメントに入社して 5 年目になりました\n\n---\n\n### 好きなもの\n\n- 関数型言語(Haskell, Elm, Scheme, Coq)\n- 筋トレはじめました\n- 最近仕事で React を書いていて気に入った React Hooks を紹介します\n\n---\n\n---\n\n## `React Hooks` とは\n\n- React 16.8 で追加された機能。\n- Functional Component に state や副作用をもたせることができる\n\n---\n\n### `React Hooks` 以前\n\n- Functional Component は Presentational Component として使う\n- state や副作用が必要な場合は Class コンポーネントや HOC を使います\n\n---\n\n### `React Hooks` 以前\n\n```jsx\nclass Users extends React.Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      company: props.company,\n      users: [],\n    };\n  }\n\n  async componentDidMount() {\n    const usersResponse = await Axios.get<User[]>('/users');\n    this.setState({ ...this.state, users: usersResponse.data });\n  }\n\n  render() {\n    return (\n      <div>\n        <h3>{this.state.company.name}</h3>\n        <ul>\n          {this.state.users.map((user) => (\n            <li key={user.id}>{user.name}</li>\n          ))}\n        </ul>\n      </div>\n    );\n  }\n}\n```\n\n---\n\n---\n\n## `Ract Hooks` でどう変わるか\n\n```jsx\nconst Users: React.FC<Props> = (props) => {\n  const [users, setUsers] = useState<User[]>([]);\n\n  useEffect(() => {\n    (async () => {\n      const usersResponse = await Axios.get<User[]>('/users');\n      setUsers(usersResponse.data);\n    })();\n  }, []);\n\n  return (\n    <div>\n      <h3>{props.company.name}</h3>\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n---\n\n### `useState`\n\n```typescript\nfunction useState<S>(\n  initialState: S | (() => S)\n): [S, Dispatch<SetStateAction<S>>];\nfunction useState<S = undefined>(): [\n  S | undefined,\n  Dispatch<SetStateAction<S | undefined>>\n];\n```\n\n- useState に値を渡すと、それを初期値とするデータとデータを更新する関数のタプルを返す。\n- データを更新する関数を使うとデータが更新され、再レンダーされる\n\n```typescript\nconst [state, setState] = useState<T>(initialValue);\n```\n\n---\n\n### `useEffect`\n\n- レンダー後に実行される(≒ componentDidMount)\n- 第二引数に依存する変数の配列を書く\n- 第二引数を設定しない場合はレンダーされるたびに実行される(≒ componentDidUpdate)\n- 第二引数に依存する変数を指定すると、その変数が変更された場合のみ実行される\n- 同じコンポーネント内で複数回使える\n- useEffect から関数を返すとクリーンアップ用関数として実行される(≒ componentWillUnmount)\n\n---\n\n### `useEffect`\n\n- 以前はライフサイクルメソッドしかなかったため複数の関心事が同じメソッド内で実行されていた。\n- useEffect は複数回使えるため関心事を分離できる\n\n---\n\n### `useEffect`\n\n別々の関心事をそれぞれの useEffect で実行している\n\n```typescript\nuseEffect(() => {\n  (async () => {\n    const usersResponse = await Axios.get<User[]>('/users');\n    setUsers(usersResponse.data);\n  })();\n}, []);\n\nuseEffect(() => {\n  const subscription = props.source.subscribe();\n  return () => {\n    subscription.unsubscribe();\n  };\n});\n```\n\n---\n\n### 関心事をカスタムフックに抽出する\n\nusers の取得部分をカスタムフックに切り出してみる\n\n```typescript\nexport const useUsers = () => {\n  const [users, setUsers] = useState<User[]>([]);\n\n  useEffect(() => {\n    (async () => {\n      const usersResponse = await Axios.get<User[]>('/users');\n      setUsers(usersResponse.data);\n    })();\n  }, []);\n\n  return { users };\n};\n```\n\n---\n\n### カスタムフックを使う\n\nprops で受け取るのと同様に扱える\n\n```jsx\nconst Users: React.FC<P> = (props) => {\n  const { users } = useUsers();\n\n  return (\n    <div>\n      <h3>{props.company.name}</h3>\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n---\n\n### カスタムフックを拡張する\n\n- ロード中の状態もほしい\n- エラーがある場合はそれもほしい\n\n---\n\n### カスタムフックを拡張する\n\n- 状態と初期値を定義する\n\n```typescript\ntype State = {\n  users: User[];\n  isLoading: boolean;\n  error?: Error;\n};\n\nconst initialState = {\n  users: [],\n  isLoading: false,\n};\n```\n\n---\n\n### カスタムフックを拡張する\n\nよしなにデータを更新してあげる\n\n```typescript\nexport const useUsers = () => {\n  const [data, setState] = useState<State>(initialState);\n\n  useEffect(() => {\n    (async () => {\n      setState({ ...data, isLoading: true });\n      try {\n        const usersResponse = await Axios.get<User[]>('/users');\n        setState({ ...data, isLoading: false, users: usersResponse.data });\n      } catch (error) {\n        setState({ ...data, isLoading: false, error: error });\n      }\n    })();\n  }, []);\n\n  return { ...data };\n};\n```\n\n---\n\n### カスタムフックを拡張する\n\nコンポーネントに組み込むと、ロジックはカスタムフックにあって、コンポーネントは状態に合わせて表示するだけになる\n\n```jsx\nconst Users: React.FC<P> = (props) => {\n  const { users, isLoading, error } = useUsers();\n\n  return (\n    <div>\n      <h3>{props.company.name}</h3>\n      {isLoading ? (\n        'Loading ...'\n      ) : error !== undefined ? (\n        <Error error={error} />\n      ) : (\n        <ul>\n          {users.map((user) => (\n            <li key={user.id}>{user.name}</li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n```\n\n---\n\n### 他の Hook\n\nよく使うもののみ\n\n- useContext\n  - グローバルな状態を扱える\n- useReducer\n  - Redux みたいなやつ\n- useMemo\n  - コンポーネント内で定義する変数をメモ化できる\n- useCallback\n  - 関数を memo 化するための hook\n\n---\n\n---\n\n## 実際使っての感想\n\n---\n\n### pros\n\n- useState や useReducer から返される値が変化するだけなのでより宣言的に書けてよい\n- class を使わないので this も使うことがなくなってよい\n- useContext と useReducer で実質 Redux みたいなこともできる\n- ロジックは hooks に寄せて単体テスト、見た目は Regression Test の体験がよい\n- TypeScript との相性がよい\n\n---\n\n### cons\n\n- useEffect で気をつけないと無限ループ\n- 配列でない値が `T | undefined` になりがち(hooks に限ったことではない)\n\n---\n\n### 最近のなやみごと\n\nHooks によって Container Component がいらなくなると思っていたけれど、useState や useEffect は結局副作用なので Presentational Component と Container Component に分けたほうがいいのではという気持ちになってきた\n\n---\n\n### おわりに\n\nAlgebraic Effect との関係などを調べて発表したかったのですが、力及ばず。\nPromise を throw するで話題になった Concurrent mode も気になってます。\n"}},"__N_SSG":true}