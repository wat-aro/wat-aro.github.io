{"pageProps":{"slide":{"title":"Ruby に型をつけるお気持ち","published":"2020/01/15","tags":["Ruby"],"slug":"feeling-to-type-ruby","content":"# Ruby に型をつけるお気持ち\n\nwat-aro\n\n---\n\n## 自己紹介\n\n- wat-aro\n- Haskell, Elm なんかが好き\n\n---\n\n## おしながき\n\n- Ruby の型のおさらい\n- ruby-signature の記法\n- 実例を通して\n\n---\n\n### `Ruby` の型のおさらい\n\n- 型検査器 steep, sorbet\n- rbi ファイルに型定義を書くがそれぞれ文法が違う\n- Ruby 3 では型シグネチャが導入される\n- 周辺ツール群は外部ライブラリとして提供\n\n---\n\n### `Ruby` の型シグナチャ\n\n- ruby-signature\n- https://github.com/ruby/ruby-signature\n- steep, sorbet にこのシグネチャを使ってもらう\n\n---\n\n---\n\n## `ruby-signature` の記法\n\n- プリミティブな型は Class instance type で定義\n- Interface type であるメソッドを持った型というのも定義できる\n- Literal type, Union Type, Intersection type, Optional type で柔軟な型定義ができる\n- ivar や メソッドの型定義も直観的\n- 型付けできないものは `untyped`\n\n---\n\n### プリミティブな型\n\n- Integer\n- String\n- Hash[Symbol, String]\n\n---\n\n### `Record type`\n\n- Hash の型を指定\n- `{ id: Integer, name: String }`\n\n---\n\n### `Interface type`\n\n例: each メソッドを持っている型\n\n```ruby\ninterface _Each[A, B]\n  def each: { (A) -> void } -> B\nend\n```\n\n---\n\n### `Literal type`\n\n- 型の取り得る値を限定できる\n- `1` という型は Integer かつ 値を `1` に限定\n- \"hello world\"という型や`:to_s`という型を定義可能\n\n---\n\n### `Union type`\n\n- 型の和を表わす\n- `Integer | String` は Integer or String\n\n---\n\n### `Intersection type`\n\n- 交差型\n- `Integer & String` は Integer and String\n- Hash の合成が主な用途？\n- `{ id: Integer } & { name: String }` は `{ id: Integer, name: String }`\n\n---\n\n### `Optional type`\n\n- みんな大好き null 安全\n- `Integer?` で `Integer | nil`\n\n---\n\n### ivar やメソッドの型定義\n\n- `@name: String` で ivar\n- `def to_s: () -> String` でメソッドを定義\n\n---\n\n### 所見\n\n- TypeScript の影響が強い\n  - Literal type\n  - Intersection type\n- Interface type があればダックタイプもやりやすそう\n- 想像していたよりもリッチ\n- any じゃなくて untyped なのはわかりやすくていい\n\n---\n\n---\n\n## 実例を通して\n\nruby-signature はまだ StandardLibrary の片付けが終わっていないので\n適当なものに型をつけてみる\n\n---\n\n### Abbrev モジュール\n\n- StandardLibrary で最初に表示されている\n- module_function abbrev 一つだけのモジュールなので簡単\n- まだ ruby-signature で定義されていない\n\n---\n\n### Abbrev#abbrev とは\n\n`abbrev(words, pattern = nil)`\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=>  {\"ruby\"=>\"ruby\", \"rub\"=>\"ruby\", \"ru\"=>\"ruby\", \"r\"=>\"ruby\"}\n\nAbbrev.abbrev(%w{ car cone })\n#=> {\"ca\"=>\"car\", \"con\"=>\"cone\", \"co\"=>\"cone\", \"car\"=>\"car\", \"cone\"=>\"cone\"}\n\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=> {\"box\"=>\"box\", \"bo\"=>\"box\", \"b\"=>\"box\", \"crab\" => \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=> {\"car\"=>\"car\", \"ca\"=>\"car\"}\n```\n\nString の配列をうけとり、String を分解して key とし、元の String を value とする Hash を返す\n\n---\n\n### まずはシンプルなケース\n\n```ruby\nAbbrev.abbrev(['ruby'])\n#=>  {\"ruby\"=>\"ruby\", \"rub\"=>\"ruby\", \"ru\"=>\"ruby\", \"r\"=>\"ruby\"}\n```\n\nこれに型を付けると\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String]) -> Hash[String, String]\nend\n```\n\n`def self?` は module function 用の書き方\n空配列を受け取っても空ハッシュを返すだけなので問題なし。\n\n---\n\n### 第 2 引数について\n\nexample を見ると String と Regexp を受け取ることを想定しているよう\n\n```ruby\nAbbrev.abbrev(%w{car box cone crab}, /b/)\n#=> {\"box\"=>\"box\", \"bo\"=>\"box\", \"b\"=>\"box\", \"crab\" => \"crab\"}\n\nAbbrev.abbrev(%w{car box cone}, 'ca')\n#=> {\"car\"=>\"car\", \"ca\"=>\"car\"}\n```\n\nじゃあ Integer とか渡したらエラーになるのかな？\n\n---\n\n### 想定していなさそうな型の引数を渡してみる\n\n```ruby\nAbbrev.abbrev(%w{12345}, 1)\n#=> {}\n```\n\nエラーにならないだと…\nこの場合って型はどうつければいいのか。\n実装を abbrev の実装を見てみると\n\n---\n\n### abbrev の実装\n\n- String, Regexp 以外は `!~` を直接使っている\n- `Integer#!~` は常に true を返す\n\n```ruby\ndef abbrev(words, pattern = nil)\n  ...\n  if pattern.is_a?(String)\n    pattern = /\\A#{Regexp.quote(pattern)}/  # regard as a prefix\n  end\n```\n\n```ruby\n  words.each do |word|\n    next if word.empty?\n    word.size.downto(1) { |len|\n      abbrev = word[0...len]\n      next if pattern && pattern !~ abbrev\n      ...\n    }\n  end\nend\n```\n\n```ruby\n  words.each do |word|\n    next if pattern && pattern !~ word\n    table[word] = word\n  end\n  table\nend\n```\n\n---\n\n### abbrev の第 2 引数は String, Regexp 以外を考慮していない\n\n- String, Regexp 以外を考慮しておらず、たまたま `{}` を返すようになっているだけに見える\n- 実行時にエラーにならない場合はどう型をつければよいのか\n  - Integer or Object を引数に取ることを認める\n  - String と Regexp 以外は認めない\n\n---\n\n### このような場合にどうすればよいか\n\n- ドキュメントにどう書かれているか\n- エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n---\n\n### ドキュメント\n\n> The optional pattern parameter is a pattern or a string.\n> Only input strings that match the pattern or start with the string are included in the output hash.\n\npattern とは言っているけれど、それが Regexp とは限定していない。\n\n---\n\n### エラーでないために困る場合を想定してどう検査してほしいかを考える\n\n何かのメソッドの返り値が String や Regexp だと思っていたのに Integer だった場合\n\n```ruby\ndef some_method: () -> (String | Integer)\n\npattern = some_method()\n\nAbbrev.abbrev([\"12345\"], pattern)\n#=> {}\n```\n\nInteger が来てここでエラーにならなくてもその後で不整合がおこる場合に困る。\nここを通るテストがない場合になぜ駄目なのかの調査が必要になる。\nそれよりも型検査で弾いてくれたほうが嬉しい。\n\n---\n\n### 結果\n\n```ruby\nmodule Abbrev\n  def self?.abbrev: (Array[String], ?(String | Regexp | nil)) -> Hash[String, String]\nend\n\n```\n\n第 2 引数は String, Regexp, nil としました。\nこの定義で ruby-signature に PR を送ってマージされた。\n\n---\n\n## まとめ\n\n- ruby-signature の紹介\n- ドキュメントにない場合でもそれっぽく動く場合がある\n- どう動いてほしいかを考えて型をつけないといけない場合がある\n"}},"__N_SSG":true}