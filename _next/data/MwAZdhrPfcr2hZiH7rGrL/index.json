{"pageProps":{"posts":[{"data":{"title":"はてなブログの記事を Next.js 製ブログにインポート","published":"2022/06/15","tags":["Rust","Next.js","TypeScript"]},"content":"\n[旧ブログ](https://wat-aro.hatenablog.com/) の記事の移行が終わりました。\nRust のパーサコンビネータ [nom](https://github.com/Geal/nom) の使いかたに慣れるため [JSON parser](https://github.com/wat-aro/wson) を作ったりと寄り道が激しかったです。\n\nはてなブログから記事をエクスポートすると [Movable Type](https://www.sixapart.jp/movabletype/) で書かれた txt ファイルをダウンロードできます。\nこれを変換して markdown で書いているこのサイトでインポートできるようにしたい。\n[Movable Type のフォーマット](https://www.sixapart.jp/movabletype/manual/3.3/f_import_format/) にちゃんと対応するのは大変なので必要なところだけ対応した。\n\n## movable_type_to_markdown\n\n作った移行ツールがこちら https://github.com/wat-aro/movable_type_to_markdown\n使ったことがなかったので [clap](https://github.com/clap-rs/clap) や [anyhow](https://github.com/dtolnay/anyhow) を使ってみた。\nto_markdown といいつつ、実際は Movable Type ファイルに入っていた html のまま。\n最初は html からマークダウンにしようかと考えていたけれどコードブロックの `pre` タグがめんどくさすぎて断念。\n\n```shell\ncargo run MOVABLE_TYPE_FILE OUTPUT_DIRECTORY\n```\n\nで OUTPUT_DIRECTORY に変換した markdown ファイルを出力できます。\n作りはシンプルに パースして記事用のオブジェクトを作成してファイル作成。\n\n## はまりどころ 1\n\nMovable Type の複数行フィールド・セクションは `-----\\n` によって区切られている。\n本文で `-----------\\n` などが使われている箇所があったためパースできなくなってしまった。\nセパレータは行頭から開始される場合に限るため `\\n-----\\n` で判定することでなんとかなった\n\n## はまりどころ 2\n\nコードブロック以外はそのままの html でそれなりに表示されているのでそれでよしとした。\nただコードブロックはいかんともしがたく。\nこれはこちらのサイト側で対応。\nはてなブログのコードブロックの `pre` タグ直下に `code` タグを入れて children をラップすると、ハイライトされないが改行はきちんと反映されることがわかった。\nただし、markdown で書いたコードブロックを使っているため、`pre` タグのクラス名に `code` が含まれている場合にはてなブログのコードブロックだと判定するようにした。\nこのサイトは `unified` を使ってマークダウンから html に変換している。\n以下の plugin を追加することでコードブロックを表示できるようにした。\n\n```ts\nexport const rehypeHatenaCodeBlock: Plugin = () => {\n  return (tree, file) => {\n    visit(tree, 'element', (node: Element) => {\n      if (\n        node.tagName == 'pre' &&\n        node.properties?.className &&\n        Array.isArray(node.properties.className) &&\n        node.properties.className.includes('code')\n      ) {\n        const children = node.children;\n        const code = {\n          type: 'element',\n          tagName: 'code',\n          properties: {},\n          children: children,\n        } as ElementContent;\n        node.children = [code];\n      }\n      return true;\n    });\n  };\n};\n```\n\n### 今後の展望\n\n今は全件表示されているため、次はページネーションを導入するぞい。\n","slug":"migrate-hatena-blog-posts"},{"data":{"title":"Next.js で URL に#を含むページを作成する","published":"2022/06/14","tags":["Next.js"]},"content":"\n## tl;dr\n\nnext.js で `#` が含まれた static page のリンクは `#` でなく `%2325` にする必要がある。\nアクセスできるようになったが、そもそも URL に `#` を入れないのがよい。\n\n## 事象\n\nはてなブログからの記事を移行する際に、記事のタイトルを markdown のファイル名にしていた。\n`/posts/Array#slice.md` を元に出力した `/posts/Arrray#slice` ページにアクセスしようとすると 404 になってしまう。\n\n## 環境\n\n- Next.js\n\n## 解決策\n\n普通に `#` だけをパーセントエンコーディングしてリンクを生成したところ、 `next dev` で実行する際はうまくいったが、 `next export` してデプロイするとアクセスできない。\n実際に `Next.js` が出力した html を見てみると ファイル名の `#` が html のファイル名の時点で `%25` に変換されていた。\nhttps://github.com/wat-aro/wat-aro.github.io/blob/47a30b9d9a1d03154b7934bfde91f3809b2006cc/posts/Array%2523slice.html\n\nアクセスする際のリンクが `/posts/Array%25slice` だとうまくいかないのはこのせいだった。\nhtml 自体が `/posts/Array%25slice` に配置されているので、ここへアクセスするためには `%25` をさらにパーセントエンコーディングしないといけない。\nURL を生成する際に `#` を `%2325` に変換すると `next export` した際にきちんと動くようになった :smile:\n\nしかし、 `next dev` ではうごかない。\n`next export` -> `#` が変換された html にアクセス\n`next dev` -> `#` を変換していない html にアクセス\nという具合の挙動になっていそう。\n`export` と `dev` でファイル名が違うため環境によって分岐しないと両方で表示できるようにはならない。\n\n`#` が入らないように調整するのが一番よさそうですね。\n","slug":"post-escapted-sharp"},{"data":{"title":"Arch Linux で日本語 man ページと英語 man ページを使い分ける","published":"2022/05/29","tags":["Linux","Arch"]},"content":"\n普段コードを書く環境ではエラーメッセージのググラビリティを考えて locale を英語にしています。\n日本語でエラーメッセージを表示しても同じ問題にひっかかっている issue や StackOverFlow などが出てきづらくなるためです。\nでも man ページを読む際には日本語のほうが楽ですよね。\nしかし日本語の man ページしか見れなくなるのも他の人に共有する際に困ってしまいます。\nここでは日本語と英語の man ページをいい感じに共存する方法を紹介します。\n\nと言ってもやることは単純で\n\n```shell\n$ LANG=ja_JP.UTF-8 yay -S man-pages-ja\n```\n\nで日本語 man をインストールし、\n\n```fish\nabbr --add jman \"LANG=ja_JP.UTF-8 man\"\n```\n\nのように `abbr` を登録するか\n\n```bash\nalias jman='LANG=ja_JP.UTF-8 man'\n```\n\nのように `alias` を登録するだけです。\n`PKGBUILD` を見るとわかるのですが、`man-pages-ja` では環境変数 `LANG` の値を見て日本語 man をインストールするディレクトリを判定しています。\n\n```shell\npackage() {\n    mkdir -p ${pkgdir}/usr/share/man/${LANG}\n    cd ${srcdir}/${pkgname}-${pkgver}\n    make install\n}\n```\n\nそのため `yay -S` する際に `LANG` を渡すことで任意のディレクトリに日本語 man をインストールできるわけです。\nこうすると `man` を叩けばオリジナルの man ページが、\n`jman` を叩くと日本語の man ページが表示できるようになります。\n\nめでたしめでたし。\n","slug":"japanese-man-page"},{"data":{"title":"JSON parser を書いた","published":"2022/05/27","tags":["Rust","nom"]},"content":"\nyak shaving で作っていた JSON parser が一応完成。  \nRust 楽しいすなあ。\n\nHaskell の parsec の感覚で使えるかと思って [nom](https://github.com/Geal/nom) を使ってみたけれど、最初はなかなかとっつきづらく。  \nまあだいたい慣れることができたのでよし！\n\nせっかくなので [crates.io](https://crates.io/) に公開したのだけれど、  \nhttps://doc.rust-jp.rs/book-ja/ch14-02-publishing-to-crates-io.html を見ながら `cargo publish` すると他の crate と比べて表示が足りない。  \n`Cargo.toml` に `respository` や `documentation` を追加する必要があったのね。\n\nhttps://crates.io/crates/wson\n\n名前は `wat-aro` の json parser で `wson` にした。  \nテストがめんどうでした。  \n[json.org](https://www.json.org/json-en.html)にはお世話になりました。\n\nさっさと movable type を変換するぞ！\n","slug":"wson"},{"data":{"title":"Playwright で OGP 画像を生成する","published":"2022/05/24","tags":["Next.js","TypeScript"]},"content":"\nブログ記事のインポートをしたかったはずなのに json parser を作る yak shaving が楽しい。  \n次は Scheme のインタプリタを作りたくなってきた。危ない。\n\nさて、表題のとおりブログの OGP 画像を [Playwright](https://github.com/microsoft/playwright) で生成するようにした。  \nこのサイトは [Next.js](https://nextjs.org/) で作って、[GitHub Pages](https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages) でホスティングしている。  \nソースコードは[ここ](https://github.com/wat-aro/wat-aro.github.io)にある。\n\nブログ記事のタイトルと slug から OGP 画像を生成している。\n\n```ts\nimport { chromium } from 'playwright';\nimport { getHtml } from './getHtml';\n\ntype Params = {\n  title: string;\n  slug: string;\n};\n\nexport const takeScreenshot = async ({ title, slug }: Params) => {\n  const browser = await chromium.launch();\n  const context = await browser.newContext({\n    viewport: { width: 1200, height: 630 },\n  });\n  const page = await context.newPage();\n  const html = getHtml({ title });\n  await page.setContent(html, { waitUntil: 'load' });\n  await page.screenshot({\n    path: `public/og-images/${slug}.png`,\n    fullPage: true,\n  });\n  await browser.close();\n};\n```\n\n`await page.setContent(html, { waitUntil: 'load' });` の `load` を指定するのが味噌。  \nまた、`setContent` に渡す html 内で画像を使う場合は[データ URL](https://developer.mozilla.org/ja/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) に base64 エンコードされた画像を渡す必要がある。  \n`setContent` には文字列を渡しているだけなためファイルパスでは Playwright は画像を特定できない。  \n後は html と css を書いたら完成。  \nこれくらいの用途だと Playwright でも Puppeteer でも変わらないね。\n\nまだまだサイトに実装しないといけないことが盛り沢山なのでがんばるぞい\n","slug":"generate-ogimage-by-playwright"},{"data":{"title":"json で nom のお勉強","published":"2022/05/16","tags":["Rust","nom"]},"content":"\n旧ブログの `movable type` を `markdown` に変換したい。  \n[nom](https://github.com/Geal/nom) でパースしようと思ったが Readme を読んでもいまいちしっくりこない。  \nparsec と同じようにはできませんか。\nとりあえず練習がてら何かをパースしてみる。  \n仕様があるほうが嬉しいので探してみると [json](https://www.json.org/json-ja.html) がよさそうだった。  \nまずは `digits` を書いてみた。  \n[digit1](https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html) を使えば終わりなのだが、それでは練習にならないため定義通りに実装。\n\nhttps://github.com/wat-aro/wjson\n\n```rust\nfn zero(input: &str) -> IResult<&str, u64> {\n    map(char('0'), |c| c.to_string().parse::<u64>().unwrap())(input)\n}\n\nfn onenine(input: &str) -> IResult<&str, u64> {\n    map(\n        alt((\n            char('1'),\n            char('2'),\n            char('3'),\n            char('4'),\n            char('5'),\n            char('6'),\n            char('7'),\n            char('8'),\n            char('9'),\n        )),\n        |c| c.to_string().parse::<u64>().unwrap(),\n    )(input)\n}\n\npub fn digit(input: &str) -> IResult<&str, u64> {\n    alt((zero, onenine))(input)\n}\n\npub fn digits(input: &str) -> IResult<&str, u64> {\n    let (rest, v) = many1(digit)(input)?;\n    let str_vec: String = v.iter().map(|d| d.to_string()).collect::<String>();\n\n    Ok((rest, str_vec.parse().unwrap()))\n}\n```\n\nまだ `Rust` を書き慣れていないけれど楽しい。\n","slug":"study-nom-by-json"},{"data":{"title":"ブログを移転しました","published":"2022/05/15"},"content":"\nhttps://wat-aro.hatenablog.com/ のブログを移転。\n`github.io` 用にドメインは前から取得していたが、やっとサイトを作成する気になった。\n今後はこちらに書いていくつもり。\n\n使用技術は\n\n- Next.js\n- TypeScript\n- Tailwind CSS\n- github.io\n\nNext.js の開発体験はいいね。  \nあまり難しいことはやらないつもりだけど、 `webassembly` まわりの何かを仕込んでみたい。  \n残作業は\n\n- 旧ブログのデータのインポート\n- OGP の設定\n- reveal.js で書いたスライドをこのサイトで表示できるようにする\n\n### 旧ブログのデータのインポート\n\nはてなブログは `Movable Type` でデータをエクスポートできる。  \nこれを `markdown` に変換して移行する予定。  \n`Rust` の練習にちょうどいいかなーと思ってる。\n\n### OGP の設定\n\n[puppeteer](https://github.com/puppeteer/puppeteer) を使う予定。  \n`next export` を叩く前に `markdown` のファイルごとにスクリーンショットを取ればいけるかと。  \n若干めんどくさくなっているが、最後まで頑張ろう。\n\n### reveal.js で書いたスライドをこのサイトで表示できるようにする\n\nプロフィールにリンクはあるけれど、これを `Next.js` で管理できるようにしたい。  \nしばらくは [About](https://wat-aro.dev/about) に書いたままにする。\n\n### 最後に\n\n数年まともにブログを書いてこなかったので今後はちゃんと書いていくつもり。  \nやるぞ！\n","slug":"moved-my-blog-to-github-io"},{"data":{"title":"RSPレジスタに対する勘違い","published":"2021/09/16"},"content":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%B8%A5%B9%A5%BF\">レジスタ</a>とスタックについて勘違いしていた。</p>\n\n<p>スタックが下に伸びていくという話から実際のデータも大きいアドレスから小さいアドレスへと順に入っているとイメージしてしまっていた。<br />\nこのような状態では<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%B8%A5%B9%A5%BF\">レジスタ</a>がスタックトップに入っているデータの先頭を指していると考えると、スタックトップよりも先にスタックトップが示すデータが入ってしまっている。<br />\n仮にこのスタックに更にpushした場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a>を進めるまえに、現在のスタックトップに入っているデータ分、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a>を進める必要が出てしまい、現在のデータの大きさをどこかに保持していないとだめになってしまう。<br />\nこの状態でスタックの計算を考えていたため混乱してしまった。</p>\n\n<p>実際にはデータはアドレスの小さいほうから大きいほうに向かって入っている。<br />\nこの場合<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a>が指すスタックトップはデータのある領域とデータのない領域の境目を指すことになる。<br />\n変数のデータ領域を確保するために、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RSP\">RSP</a>を減算する時は変数のバイトサイズ分引くだけでよい。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/w/wat-aro/20210916/20210916221321.png\" alt=\"f:id:wat-aro:20210916221321p:plain\" width=\"826\" height=\"583\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>低レイヤわからん</p>\n\n","slug":"RSPレジスタに対する勘違い"},{"data":{"title":"container 内で wasm-pack test を実行すると bind() failed: Cannot assign requested address (99) になる","published":"2021/08/25"},"content":"\n<p>wasm-pack を使える Docker 環境を作成し、その中で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\">チュートリアル</a>をしていたところ、タイトルのようなエラーが出て <code>wasm-pack test</code> が実行できなかった。<br />\nこのコンテナでは rust, wasm-pack, npm が使えるだけの状態で、コンテナ内に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a> がインストールされていないことが原因だった。<br />\nDockerfile に <code>google-chrome-stable</code> を追加すると無事実行できるようになりました。</p>\n\n<pre class=\"code lang-diff\" data-lang=\"diff\" data-unlink><span class=\"synSpecial\">-RUN apt-get update -qq \\</span>\n<span class=\"synSpecial\">- &amp;&amp; apt-get install -y libnss3</span>\n<span class=\"synIdentifier\">+RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add \\</span>\n<span class=\"synIdentifier\">+  &amp;&amp; echo 'deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main' | tee /etc/apt/sources.list.d/google-chrome.list \\</span>\n<span class=\"synIdentifier\">+  &amp;&amp; apt-get update -qq \\</span>\n<span class=\"synIdentifier\">+  &amp;&amp; apt-get install -y google-chrome-stable libnss3 libgconf-2-4</span>\n</pre>\n\n\n<p>chromedriver が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ipv6\">ipv6</a> の subnet を探しているんじゃないかなどかなり回り道をしてしまった</p>\n\n","slug":"container 内で wasm-pack test を実行すると bind() failed: Cannot assign requested address (99) になる"},{"data":{"title":"Chrome などで Emacs キーバインディングを使う","published":"2020/02/24"},"content":"\n<p><code>~/.config/gtk-3.0/settings.ini</code> に追記する</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>[Settings]\ngtk-key-theme-name = Emacs</pre>\n\n\n<p><a href=\"https://askubuntu.com/questions/124815/how-do-i-enable-emacs-keybindings-in-apps-such-as-google-chrome/918962#918962\">gtk - How do I enable Emacs keybindings in apps, such as Google Chrome? - Ask Ubuntu</a></p>\n\n","slug":"Chrome などで Emacs キーバインディングを使う"},{"data":{"title":"emacs で fcitx-mozc を使う","published":"2020/02/23","tags":["Arch","mozc","emacs","fcitx"]},"content":"\n<p>今はこの記事のやり方のほうがよい</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fain0204.hatenablog.com%2Fentry%2F2016%2F08%2F12%2F235206\" title=\"Arch Linuxにemacs-mozcをインストールした話 - twitterよりちょっと長いの\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://ain0204.hatenablog.com/entry/2016/08/12/235206\">ain0204.hatenablog.com</a></cite></p>\n\n<hr />\n\n<p>以下は今だとうまく動かない</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -G fcitx-mozc</pre>\n\n\n<p><code>PKGBUILD</code> を編集する。</p>\n\n<pre class=\"code lang-diff\" data-lang=\"diff\" data-unlink><span class=\"synSpecial\">-  _targets=&quot;server/server.gyp:mozc_server gui/gui.gyp:mozc_tool unix/fcitx/fcitx.gyp:fcitx-mozc&quot;</span>\n<span class=\"synIdentifier\">+  _targets=&quot;server/server.gyp:mozc_server gui/gui.gyp:mozc_tool unix/fcitx/fcitx.gyp:fcitx-mozc unix/emacs/emacs.gyp:mozc_emacs_helper&quot;</span>\n\n   install -D -m 755 out_linux/${_bldtype}/mozc_server &quot;${pkgdir}/usr/lib/mozc/mozc_server&quot;\n   install    -m 755 out_linux/${_bldtype}/mozc_tool   &quot;${pkgdir}/usr/lib/mozc/mozc_tool&quot;\n\n<span class=\"synIdentifier\">+  install -D -m 755 out_linux/${_bldtype}/mozc_emacs_helper &quot;${pkgdir}/usr/bin/mozc_emacs_helper&quot;</span>\n<span class=\"synIdentifier\">+</span>\n   install -d &quot;${pkgdir}/usr/share/licenses/$pkgname/&quot;\n   install -m 644 LICENSE data/installer/*.html &quot;${pkgdir}/usr/share/licenses/${pkgname}/&quot;\n</pre>\n\n\n<p>手動でインストール</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ cd fcitx-mozc\n$ makepkg -si\n\n# 不明な公開鍵についてのエラーがでる\n$ sudo pacman-key --recv-keys &lt;keyid&gt;\n$ gpg --recv-keys &lt;keyid&gt;\n\n$ makepkg -si</pre>\n\n\n<p>これで <code>/usr/bin/mozc_emacs_helper</code> が入る。\nあとは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/emacs\">emacs</a>の設定をする。</p>\n\n<pre class=\"code elisp\" data-lang=\"elisp\" data-unlink>(use-package mozc\n  :init\n  (setq default-input-method &#34;japanese-mozc&#34;)\n  :custom\n  (mozc-candidate-style &#39;overlay))</pre>\n\n\n","slug":"emacs で fcitx-mozc を使う"},{"data":{"title":"X1 Carbon Gen 7th に Arch Linux をインストール","published":"2020/02/11","tags":["Arch"]},"content":"\n<p>基本的にはインストールガイドのとおり\n<a href=\"https://wiki.archlinux.jp/index.php/\">https://wiki.archlinux.jp/index.php/</a>インストールガイド\nWindowManager は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/XMonad\">XMonad</a></p>\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D1%A1%BC%A5%C6%A5%A3%A5%B7%A5%E7%A5%F3\">パーティション</a></h2>\n\n<p>funtoo を参考\n<a href=\"https://www.funtoo.org/Install/GPT_Partitioning\">https://www.funtoo.org/Install/GPT_Partitioning</a></p>\n\n<h2>フォーマット</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># mkfs.fat -F32 /dev/nvme0n1p1 # ESP\n# fatlabel /dev/nvme0n1p1 efi\n# mkfs.btrfs -L root /dev/nvme0n1p3 # Root\n# mkswap /dev/nvme0n1p2\n# swapon /dev/nvme0n1p2</pre>\n\n\n<h2>マウント</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># mount /dev/nvme0n1p3 /mnt\n# mkdir /mnt/boot\n# mount /dev/nvme0n1p1 /mnt/boot</pre>\n\n\n<h2>システムクロックの更新</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># timedatectl set-ntp true</pre>\n\n\n<h2>インストール</h2>\n\n<p>Japanのミラーのみを使うように変更</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># vim /etc/pacman.d/mirrorlist</pre>\n\n\n\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pacstrap /mnt base linux linux-firmware</pre>\n\n\n<h2>システムの設定</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># genfstab -L /mnt &gt;&gt; /mnt/etc/fstab\n# cat /mnt/etc/fstab</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chroot\">chroot</a></h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># arch-chroot /mnt</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%BE%A1%BC%A5%F3\">タイムゾーン</a></h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># ln -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime\n# hwclock --systohc --utc</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%ED%A5%B1%A1%BC%A5%EB\">ロケール</a></h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pacman -S neovim\n# nvim /etc/locale.gen</pre>\n\n\n<p><code>ja_JP.UTF-8 UTF-8</code> と <code>en_US.UTF-8 UTF-8</code> をアンコメント</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># locale-gen\n# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</pre>\n\n\n<h2>ネットワーク</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pacman -S networkmanager\n# systemctl enable NetworkManager.service</pre>\n\n\n<h2>Rootパスワード</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># passwd</pre>\n\n\n<h2>ブート</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pacman -S efibootmgr\n# efibootmgr -d /dev/nvme0n1 -p 1 -c -L &#34;Arch Linux&#34; -l /vmlinuz-linux -u &#34;root=/dev/nvme0n1p3 rw initrd=/initramfs-linux.img&#34;\n# exit\n# reboot</pre>\n\n\n<h2>ユーザ追加</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pass\n# useradd -m -g users -G wheel -s /bin/bash wat-aro\n# passwd wat-aro\n# groupadd wat-aro\n# gpasswd -a wat-aro wat-aro\nid wat-aro</pre>\n\n\n<h2>sudo</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink># pacman -S sudo\n# EDITOR=nvim visudo</pre>\n\n\n<p>以下を追記</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>%wheel ALL=(ALL) ALL</pre>\n\n\n<h2>Yay</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ sudo pacman -S git\n$ sudo pacman -S base-devel\n$ git clone https://aur.archlinux.org/yay.git\n$ cd yay\n$ makepkg -si</pre>\n\n\n<h2>man</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -S man-db\n$ mandb</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Xorg\">Xorg</a></h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -S xorg-server\n$ lspci | grep -e VGA -e 3D\n$ yay -S xf86-video-intel\n$ yay -S xorg-xrdb rxvt-unicode xorg-xmodmap</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GUI\">GUI</a> 準備</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/uim\">uim</a> の設定が終わるまで <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/xmonad\">xmonad</a> がちゃんと動かない</p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ git clone https://github.com/wat-aro/dotfiles\n$ cd dotfiles\n$ ./install.sh\n$ yay -S xmonad xmonad-contrib dmenu xmobar\n$ xmonad --recompile</pre>\n\n\n<h2>日本語入力</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -S uim anthy gtk3\n$ uim-pref-gtk3</pre>\n\n\n<h2>ブラウザ</h2>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -S noto-fonts noto-fonts-cjk noto-fonts-emoji\n$ yay -S google-chrome</pre>\n\n\n<h2>フォント</h2>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ricty\">Ricty</a> を手動で入れる</p>\n\n<h2>LightDM</h2>\n\n<p><a href=\"https://wiki.archlinux.jp/index.php/LightDM\">LightDM - ArchWiki</a></p>\n\n<p><a href=\"https://qiita.com/Hayao0819/items/7784178c7fd568291905\">&#x3010;ArchLinux&#x3011;&#x6700;&#x9AD8;&#x306E;&#x30ED;&#x30B0;&#x30A4;&#x30F3;&#x753B;&#x9762; - Qiita</a></p>\n\n<p>を参考</p>\n\n<h2>オーディオ</h2>\n\n<p>オーディオを有効にするためには <code>sof-firmware</code> も必要</p>\n\n<p><a href=\"https://www.reddit.com/r/archlinux/comments/e5rpxv/thinkpad_x1_carbon_gen_7_audio_broken_on_541arch11/\">Thinkpad X1 Carbon Gen 7 audio broken on 5.4.1-arch1-1 : archlinux</a></p>\n\n<pre class=\"code shell\" data-lang=\"shell\" data-unlink>$ yay -S alsa-utils sof-firmware pulseaudio pavucontrol</pre>\n\n\n","slug":"X1 Carbon Gen 7th に Arch Linux をインストール"},{"data":{"title":"ActiveModel::Attributesでカスタムタイプを使う","published":"2018/08/07"},"content":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Rails\">Rails</a> 5.2.0 で入ったActiveModel::Attributes <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> 最高ですよね。</p>\n\n<p>でもカスタムタイプのドキュメントが見つからないんですよね。 <a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html#method-i-attribute\">ActiveRecord::Attributes API のカスタムタイプ</a> ならあるのですが。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>見たところ簡単に作れるのがわかったので紹介します。</p>\n\n<p>まず型の登録部分ですが、<a href=\"https://github.com/rails/rails/blob/5-2-0/activemodel/lib/active_model/type.rb#L20-L53\">lib/active_model/type.rb</a> で定義されています。</p>\n\n<p>また、<a href=\"https://github.com/rails/rails/blob/5-2-0/activemodel/lib/active_model/type/boolean.rb\">ActiveModelで使われているデフォルトタイプの実装</a>を見ると <code>cast_value</code> メソッドがあればよさそうです。</p>\n\n<p><a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html#method-i-attribute\">ActiveRecord::Attributes API</a> と同様に実装します。</p>\n\n<pre class=\"code lang-ruby\" data-lang=\"ruby\" data-unlink><span class=\"synPreProc\">class</span> <span class=\"synType\">MoneyType</span> &lt; <span class=\"synType\">ActiveModel</span>::<span class=\"synType\">Type</span>::<span class=\"synType\">Integer</span>\n  <span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">cast_value</span>(value)\n    <span class=\"synStatement\">if</span> !value.kind_of?(<span class=\"synType\">Numeric</span>) &amp;&amp; value.include?(<span class=\"synSpecial\">'</span><span class=\"synConstant\">$</span><span class=\"synSpecial\">'</span>)\n      price_in_dollars = value.gsub(<span class=\"synSpecial\">/\\$/</span>, <span class=\"synSpecial\">''</span>).to_f\n      <span class=\"synStatement\">super</span>(price_in_dollars * <span class=\"synConstant\">100</span>)\n    <span class=\"synStatement\">else</span>\n      <span class=\"synStatement\">super</span>\n    <span class=\"synStatement\">end</span>\n  <span class=\"synPreProc\">end</span>\n<span class=\"synPreProc\">end</span>\n\n<span class=\"synComment\"># config/initializers/types.rb</span>\n<span class=\"synType\">ActiveModel</span>::<span class=\"synType\">Type</span>.register(<span class=\"synConstant\">:money</span>, <span class=\"synType\">MoneyType</span>)\n\n<span class=\"synComment\"># app/models/store_listing.rb</span>\n<span class=\"synPreProc\">class</span> <span class=\"synType\">StoreListing</span>\n  <span class=\"synPreProc\">include</span> <span class=\"synType\">ActiveModel</span>::<span class=\"synType\">Model</span>\n  <span class=\"synPreProc\">include</span> <span class=\"synType\">ActiveModel</span>::<span class=\"synType\">Attributes</span>\n\n  attribute <span class=\"synConstant\">:price_in_cents</span>, <span class=\"synConstant\">:money</span>\n<span class=\"synPreProc\">end</span>\n\nstore_listing = <span class=\"synType\">StoreListing</span>.new(<span class=\"synConstant\">price_in_cents</span>: <span class=\"synSpecial\">'</span><span class=\"synConstant\">$10.00</span><span class=\"synSpecial\">'</span>)\nstore_listing.price_in_cents <span class=\"synComment\"># =&gt; 1000</span>\n</pre>\n\n\n<p>このように ActiveModel::Attributes でカスタムタイプを使うことができます。</p>\n\n","slug":"ActiveModel::Attributesでカスタムタイプを使う"},{"data":{"title":"http-conduit で取得したデータを日本語表示する","published":"2018/02/27","tags":["Haskell"]},"content":"\n<p>簡単な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>ツールを書こうとしたら http-conduit で取得したデータの日本語表示でハマってしまいました。</p>\n\n<p><code>http-conduit</code> の <code>httpLbs</code> で取得したデータをそのままターミナルに出力します。<br/>\n必要なパッケージは <code>http-conduit</code> <code>bytestring</code> <code>utf8-string</code> の３つ。</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink><span class=\"synSpecial\">{-# LANGUAGE OverloadedStrings #-}</span>\n\n<span class=\"synPreProc\">import</span> <span class=\"synPreProc\">qualified</span> Codec.Binary.UTF8.String <span class=\"synPreProc\">as</span> Codec\n<span class=\"synPreProc\">import</span>           Data.ByteString.Char8    (unpack)\n<span class=\"synPreProc\">import</span>           Data.ByteString.Lazy     (toStrict)\n<span class=\"synPreProc\">import</span> <span class=\"synPreProc\">qualified</span> Network.HTTP.Simple      <span class=\"synPreProc\">as</span> Simple\n\nmain <span class=\"synStatement\">::</span> IO ()\nmain <span class=\"synStatement\">=</span> <span class=\"synStatement\">do</span>\n    res <span class=\"synStatement\">&lt;-</span> Simple.httpLbs <span class=\"synConstant\">&quot;https://twitter.com/&quot;</span>\n\n    putStrLn <span class=\"synStatement\">$</span> Codec.decodeString <span class=\"synStatement\">$</span> unpack <span class=\"synStatement\">$</span> toStrict <span class=\"synStatement\">$</span> Simple.getResponseBody res\n</pre>\n\n\n<p><code>httpLbs</code> を使い取得したデータは <code>Reponse</code> 型で包まれているので <code>getResponseBody</code> で <code>ByteString</code> を取得し、 <code>String</code> に変換して出力します。<br/>\nなぜか <code>ByteString</code> でなく <code>ByteString.Lazy</code> になっていたので <code>toStrict</code> で変換。<br/>\nそして <code>unpack</code> しても日本語が表示されないため、 <code>Codec.Binary.UTF8.String</code> の <code>decodeString</code> で変換してから表示。</p>\n\n<p>文字列難しい</p>\n\n<p>[参考]</p>\n\n<p><a href=\"https://qiita.com/lotz/items/f8440fa08a62d1c44e1a\">Haskell&#x304B;&#x3089;&#x7C21;&#x5358;&#x306B;Web API&#x3092;&#x53E9;&#x304F;&#x65B9;&#x6CD5; - Qiita</a></p>\n\n<p><a href=\"https://qiita.com/satosystems/items/e07e9907e4da9ab853fc\">Haskell &#x6587;&#x5B57;&#x5217;&#x5909;&#x63DB;&#x5165;&#x9580; - Qiita</a></p>\n\n","slug":"http-conduit で取得したデータを日本語表示する"},{"data":{"title":"プログラミング Coq 証明駆動開発(1)","published":"2017/05/11"},"content":"\n<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt8.html\">&#x8A3C;&#x660E;&#x99C6;&#x52D5;&#x958B;&#x767A;&#x5165;&#x9580;(1)</a></p>\n\n<p><code>何かを読む会</code> という社内勉強会が発足されました。\n読んだ本の内容を共有しよう。\n一人で勉強していてもダレるので共有することで無理やり進捗を出そう。\n他の人の発表を聞いて読んだ気になろう。\nっていう緩めの会です。\n途中まで読んで放置していたプログラミング Coq の続きを読んでまとめました。</p>\n\n<h1>挿入ソートを証明する。</h1>\n\n<p>証明したいことは次の二点。</p>\n\n<ul>\n<li>挿入前と挿入後で要素に変化がないこと(isort_permutation)</li>\n<li>挿入後に要素が整列されていること(isort_sorted)</li>\n</ul>\n\n\n<p>上記を型で示すと以下のようになる。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>isort_permutation : forall (l : list nat), Permutation l (insertion_sort l)\nisort_sorted      : forall (l : list nat), LocallySorted le (insertion_sort l)</pre>\n\n\n<h2>実装</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Require Import List.\nRequire Import Arith.\n\nFixpoint insert (a : nat) (l : list nat) : list nat :=\n  match l with\n  | nil =&gt; a :: nil\n  | x :: xs =&gt; if leb a x then a :: l else x :: insert a xs\n  end.\n\nFixpoint insertion_sort (l : list nat) : list nat :=\n  match l with\n  | nil =&gt; nil\n  | x :: xs =&gt; insert x (insertion_sort xs)\n  end.</pre>\n\n\n<h2>要素の変化がないこと</h2>\n\n<p>あるリストがあるリストと同じ要素で成り立っているのは以下のモジュールで定義されている。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Inductive Permutation : list A -&gt; list A -&gt; Prop :=\n  | perm_nil: Permutation [] []\n  | perm_skip x l l&#39; : Permutation l l&#39; -&gt; Permutation (x::l) (x::l&#39;)\n  | perm_swap x y l : Permutation (y::x::l) (x::y::l)\n  | perm_trans l l&#39; l&#39;&#39; : Permutation l l&#39; -&gt; Permutation l&#39; l&#39;&#39; -&gt; Permutation l l&#39;&#39;.</pre>\n\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は同じ要素から成り立つ</li>\n<li>l と l' が同じ要素から成り立つならば x :: l と x :: l' も同じ要素から成り立つ</li>\n<li>y :: x :: l と x :: y :: l は同じ要素から成り立つ</li>\n<li>(l と l' が同じ要素から成り立ち、l' と l'&lsquo; が同じ要素から成り立つ) ならば l と l&rsquo;&lsquo; も同じ要素から成り立つ</li>\n</ol>\n\n\n<h2>isort_permutation の証明</h2>\n\n<p>isort_permutation の型</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation l (insertion_sort l)</pre>\n\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を使う。\nl が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の時は insertion_sort l は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> なので\nPermutation <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり自明。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>のため、nの場合にあたる仮定は</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation xs (insertion_sort xs)</pre>\n\n\n<p>n + 1 に当たる命題は</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation x :: xs (insertion_sort x::xs)</pre>\n\n\n<p>となり、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permutation x :: xs (insert x (insertion_sort xs)</pre>\n\n\n<p>と変形できる。</p>\n\n<p>つまり</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : list nat), Permuation x :: xs (x :: insertion_sort xs)</pre>\n\n\n<p>と</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall (l : lsit nat), Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)</pre>\n\n\n<p>を示すことで perm_trans から</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>forall l l&#39; l&#39;&#39; , Permutation l l&#39; -&gt; Permutation l&#39; l&#39;&#39; -&gt; Permutation l l&#39;&#39;</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Permutation (x :: xs) (x :: insertion_sort xs) -&gt;\n  Permutation (x :: insertion_sort xs) (insert x (insertion_sort xs)) -&gt;\n    Permutation (x :: xs) (insert x (insertion_sort xs))</pre>\n\n\n<p>となり、導ける。</p>\n\n<p>A  については 仮定と Permutation のコンストラクタ</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>perm_skip : forall x l l&#39;, Permutation l l&#39; -&gt; Permutation (x :: l) (x :: l&#39;)</pre>\n\n\n<p>から導ける。</p>\n\n<p>まず B を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明する。</p>\n\n<p>isort_permutaiton の証明は以下。</p>\n\n<table>\n<thead>\n<tr>\n<th> 命令 </th>\n<th> 説明 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> intros </td>\n<td> forall などから変数を仮定へ移動する </td>\n</tr>\n<tr>\n<td> simpl </td>\n<td> 簡約 </td>\n</tr>\n<tr>\n<td> apply </td>\n<td> 仮定や定理などを適用 </td>\n</tr>\n<tr>\n<td> destruct </td>\n<td> 条件分岐しているものなどを subgoal に分ける </td>\n</tr>\n<tr>\n<td> induction </td>\n<td> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>を実施するために subgoal に分ける </td>\n</tr>\n</tbody>\n</table>\n\n\n<p>どういうふうに証明が進むかは coq <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a> や proof-general 使って見てください。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Require Import List.\nRequire Import Arith.\nRequire Import Sorting.Permutation.\nRequire Import Sorting.Sorted.\n\n(* isort_permutation *)\n\nLemma insert_perm : forall (x : nat)(l : list nat), Permutation (x :: l) (insert x l).\n  induction l.\n  intros.\n  simpl.\n  apply Permutation_refl.\n\n  intros.\n  simpl.\n  destruct (leb x a).\n\n  apply Permutation_refl.\n\n  apply perm_trans with (a :: x :: l).\n  apply perm_swap.\n\n  apply perm_skip.\n  apply IHl.\nQed.\n\nTheorem isort_permutation : forall (l : list nat), Permutation l (insertion_sort l).\n  induction l.\n  apply perm_nil.\n  simpl.\n  apply perm_trans with (a :: insertion_sort l).\n  apply perm_skip.\n  apply IHl.\n  apply insert_perm.\nQed.</pre>\n\n\n<h2>整列の定義</h2>\n\n<p>リスト l が整列されていることはSorting.Sortedモジュールで定義されている.</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Induction LocallySorted (A : Type) (R : A -&gt; A -&gt; Prop) : list A :=\n  | LSorted_nil : LocallySorted R nil\n  | LSorted_cons1 : forall a : A, LocallySorted R (a :: nil)\n  | LSorted_consn : forall (a b : A) (l : list A),\n    LocallySorted R (b :: l) -&gt;\n      R a b -&gt; LocallySorted R (a :: b :: l)</pre>\n\n\n<p>上の定義は次のような意味です。\nR a b は a &lt; b のようなものです。</p>\n\n<ol>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>x :: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> は整列している</li>\n<li>b :: l が整列しているとき, R a b ならば a :: b :: l は整列している</li>\n</ol>\n\n\n<h2>整列されていることの証明</h2>\n\n<p>こちらでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B5%A2%C7%BC%CB%A1\">帰納法</a>で考える。\nまず l が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> の場合は insertion_sort <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> となり、LSorted_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> : LocallySorted le <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/nil\">nil</a> から明らか。</p>\n\n<p>LocallySort le (insertion_sort l) -> LocallySort le (insertion_sort (a :: l)) の場合を考える。\nLocallySort le (insertion_sort (a ::l) は LocallySort le (insert a (insertion_sort l))と変形できる。\nこの時、insertion_sort l は仮定より整列しているため、</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>insert_sorted : forall (a : nat) (l : list a), LocallySort le l -&gt; LocallySorted le (insert a l)</pre>\n\n\n<p>を示すことができれば証明できる。</p>\n\n<p>これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CA%E4%C2%EA\">補題</a>として証明をすすめる。</p>\n\n<h2>整列の証明</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Lemma insert_sorted : forall (a : nat) (l : list nat),\n    LocallySorted le l -&gt; LocallySorted le (insert a l).\n  induction l.\n  constructor.\n\n  intro.\n  simpl.\n  remember (leb a a0).\n  destruct b.\n\n  apply LSorted_consn.\n  apply H.\n  apply leb_complete.\n  congruence.\n\n  inversion H.\n  simpl.\n  apply LSorted_consn.\n  apply LSorted_cons1.\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  subst.\n  simpl.\n  simpl in IHl.\n  remember (leb a b).\n\n  destruct b0.\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n\n  apply lt_le_weak.\n  apply leb_complete_conv.\n  congruence.\n\n  apply LSorted_consn.\n  apply IHl.\n  apply H2.\n  apply H3.\nQed.</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Theorem isort_sorted : forall (l : list nat) , LocallySorted le (insertion_sort l).\n  induction l.\n  constructor.\n\n  simpl.\n\n  apply insert_sorted.\n  apply IHl.\nQed.</pre>\n\n\n<p>これで isertion_sort はソートの前後で要素が変わらないことと、ソート後に整列されていることが証明できた。</p>\n\n","slug":"プログラミング Coq 証明駆動開発(1)"},{"data":{"title":"プログラミング Coq (証明駆動開発 2)","published":"2017/05/11"},"content":"\n<p><a href=\"http://www.iij-ii.co.jp/lab/techdoc/coqt/coqt9.html\">&#x8A3C;&#x660E;&#x99C6;&#x52D5;&#x958B;&#x767A;&#x5165;&#x9580;(2)</a></p>\n\n<p>上記ページの勉強メモです。</p>\n\n<h1>Extraction</h1>\n\n<p>coq から <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> のコードを出力する。<br></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> にコードを出力するにはそのまま<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction map.</pre>\n\n\n<p>とすればいい。<br>\nこれで</p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val map : ('a1 -&gt; 'a2) -&gt; 'a1 list -&gt; 'a2 list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">Nil</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">Nil</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">(</span>a, t<span class=\"synStatement\">)</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">Cons</span> <span class=\"synStatement\">((</span>f a<span class=\"synStatement\">)</span>, <span class=\"synStatement\">(</span>map f t<span class=\"synStatement\">))</span>\n</pre>\n\n\n<p>と出力される。（proof-general を使っています。coq-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ide\">ide</a>の場合はcommand pane で実行）<br></p>\n\n<p>この時、list が <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストでなく coq で定義された list になっている。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使うには<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].</pre>\n\n\n<p>を実行する。こうすると<br></p>\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val map : ('a1 -&gt; 'a2) -&gt; 'a1 list -&gt; 'a2 list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> map f <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> a<span class=\"synStatement\">::</span>t <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">(</span>f a<span class=\"synStatement\">)::(</span>map f t<span class=\"synStatement\">)</span>\n</pre>\n\n\n<p>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> 組み込みのリストを使ったmap関数が生成される。<br></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>  や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> に出力するにはそれぞれ<br>\n<code>Extraction Language Haskell.</code> <code>Extraction Language Scheme.</code> としてから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合と同じように出力する。<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Haskell.\nExtract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].\nExtraction map.</pre>\n\n\n\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>map <span class=\"synStatement\">::</span> (a1 <span class=\"synStatement\">-&gt;</span> a2) <span class=\"synStatement\">-&gt;</span> (list a1) <span class=\"synStatement\">-&gt;</span> list a2\nmap f l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> [];\n   (<span class=\"synStatement\">::</span>) a t <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">::</span>) (f a) (map f t)}\n</pre>\n\n\n<p>正しいけど、あまり綺麗なコードじゃない。<br></p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>map <span class=\"synStatement\">::</span> (a <span class=\"synStatement\">-&gt;</span> b) <span class=\"synStatement\">-&gt;</span> (list a) <span class=\"synStatement\">-&gt;</span> list b\nmap f [] <span class=\"synStatement\">=</span> []\nmap f x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">=</span> (f x) <span class=\"synStatement\">::</span> (map f xs)\n</pre>\n\n\n<p>くらいには変換してほしいけど、元の形からすると厳しいのかな。<br></p>\n\n<p>次は <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/scheme\">scheme</a>.<br></p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Scheme.\nExtraction map.</pre>\n\n\n\n\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> <span class=\"synIdentifier\">map</span> <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>f l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> a t<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,(</span>f a<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">,(</span>@ <span class=\"synIdentifier\">map</span> f t<span class=\"synSpecial\">))))))</span>\n</pre>\n\n\n<p>おお。lambdas ってなんだ。match なんて RnRSにないぞ。というか、準クオート使ってるし、<code>,</code>使った式展開も入ってる。<br>\nCoq Extension <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a> っていうのがあって、lambdas マクロやmatch マクロ、@マクロが定義されているわけか。<br>\nlambdas マクロと @マクロはなかなかよい。<br>\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> っぽく書きたい時は便利そう。<br>\nmatch マクロは define-syntax みたいな感じかな？<br>\n直接変換するならたしかにこういうマクロ欲しくなるな。<br></p>\n\n<h2>insertion_sort の変換</h2>\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>の場合</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Ocaml.\n\nExtract Inductive list =&gt; &#34;list&#34; [&#34;[]&#34; &#34;(::)&#34;].\nExtract Inductive bool =&gt; &#34;bool&#34; [&#34;true&#34; &#34;false&#34;].\nExtract Inductive nat =&gt; int [&#34;0&#34; &#34;succ&#34;] &#34;(fun fO fS n -&gt; if n = 0 then f O () else fS (n-1))&#34;.\nExtraction insert.\nExtraction insertion_sort.</pre>\n\n\n\n\n<pre class=\"code lang-ocaml\" data-lang=\"ocaml\" data-unlink><span class=\"synComment\">(** val insert : int -&gt; int list -&gt; int list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insert a l <span class=\"synStatement\">=</span> <span class=\"synStatement\">match</span> l <span class=\"synStatement\">with</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> a<span class=\"synStatement\">::</span><span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-&gt;</span> <span class=\"synStatement\">if</span> <span class=\"synPreProc\">Nat</span>.leb a x <span class=\"synStatement\">then</span> a<span class=\"synStatement\">::</span>l <span class=\"synStatement\">else</span> x<span class=\"synStatement\">::(</span>insert a xs<span class=\"synStatement\">)</span>\n\n<span class=\"synComment\">(** val insertion_sort : int list -&gt; int list **)</span>\n\n<span class=\"synStatement\">let</span> <span class=\"synStatement\">rec</span> insertion_sort <span class=\"synStatement\">=</span> <span class=\"synStatement\">function</span>\n<span class=\"synStatement\">|</span> <span class=\"synConstant\">[]</span> <span class=\"synStatement\">-&gt;</span> <span class=\"synConstant\">[]</span>\n<span class=\"synStatement\">|</span> x<span class=\"synStatement\">::</span>xs <span class=\"synStatement\">-&gt;</span> insert x <span class=\"synStatement\">(</span>insertion_sort xs<span class=\"synStatement\">)</span>\n</pre>\n\n\n<h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a>の場合</h3>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Haskell.\n\nExtract Inductive list =&gt; &#34;([])&#34; [&#34;[]&#34; &#34;(:)&#34;].\nExtract Inductive bool =&gt; &#34;Bool&#34; [&#34;True&#34; &#34;False&#34;].\nExtract Inductive nat =&gt; Int [&#34;0&#34; &#34;succ&#34;] &#34;(\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))&#34;.</pre>\n\n\n\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>insert <span class=\"synStatement\">::</span> Int <span class=\"synStatement\">-&gt;</span> (([]) Int) <span class=\"synStatement\">-&gt;</span> ([]) Int\ninsert a l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) a [];\n   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-&gt;</span>\n    <span class=\"synStatement\">case</span> leb a x <span class=\"synStatement\">of</span> {\n     True <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) a l;\n     False <span class=\"synStatement\">-&gt;</span> (<span class=\"synStatement\">:</span>) x (insert a xs)}}\n\ninsertion_sort <span class=\"synStatement\">::</span> (([]) Int) <span class=\"synStatement\">-&gt;</span> ([]) Int\ninsertion_sort l <span class=\"synStatement\">=</span>\n  <span class=\"synStatement\">case</span> l <span class=\"synStatement\">of</span> {\n   [] <span class=\"synStatement\">-&gt;</span> [];\n   (<span class=\"synStatement\">:</span>) x xs <span class=\"synStatement\">-&gt;</span> insert x (insertion_sort xs)}\n</pre>\n\n\n<h2><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Scheme\">Scheme</a>の場合</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Scheme.\n\nExtraction insert.\nExtraction insertion_sort.</pre>\n\n\n\n\n<pre class=\"code lang-scheme\" data-lang=\"scheme\" data-unlink><span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insert <span class=\"synSpecial\">(</span>lambdas <span class=\"synSpecial\">(</span>a l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,`(</span>Nil<span class=\"synSpecial\">)))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span>\n       <span class=\"synSpecial\">(</span>match <span class=\"synSpecial\">(</span>@ leb a x<span class=\"synSpecial\">)</span>\n          <span class=\"synSpecial\">((</span>True<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>a <span class=\"synSpecial\">,</span>l<span class=\"synSpecial\">))</span>\n          <span class=\"synSpecial\">((</span>False<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Cons <span class=\"synSpecial\">,</span>x <span class=\"synSpecial\">,(</span>@ insert a xs<span class=\"synSpecial\">))))))))</span>\n\n<span class=\"synSpecial\">(</span><span class=\"synStatement\">define</span> insertion_sort <span class=\"synSpecial\">(</span><span class=\"synStatement\">lambda</span> <span class=\"synSpecial\">(</span>l<span class=\"synSpecial\">)</span>\n  <span class=\"synSpecial\">(</span>match l\n     <span class=\"synSpecial\">((</span>Nil<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">`(</span>Nil<span class=\"synSpecial\">))</span>\n     <span class=\"synSpecial\">((</span><span class=\"synIdentifier\">Cons</span> x xs<span class=\"synSpecial\">)</span> <span class=\"synSpecial\">(</span>@ insert x <span class=\"synSpecial\">(</span>insertion_sort xs<span class=\"synSpecial\">))))))</span>\n</pre>\n\n\n<h2>ファイルへの出力</h2>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>Extraction Language Ocaml.\nExtraction &#34;insertion_sort.ml&#34; insertion_sort.</pre>\n\n\n<p>と入力して proof-general で C-c C-n すると以下のようなファイルが生成された。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Nat =\n struct\n  (** val leb : Int -&gt; Int -&gt; Bool **)\n\n  let rec leb n m =\n    (\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))\n      (fun _ -&gt;\n      True)\n      (fun n&#39; -&gt;\n      (\\fO fS n -&gt; if n == 0 then fO () else fS (n-1))\n        (fun _ -&gt;\n        False)\n        (fun m&#39; -&gt;\n        leb n&#39; m&#39;)\n        m)\n      n\n end\n\n(** val insert : Int -&gt; Int ([]) -&gt; Int ([]) **)\n\nlet rec insert a l = match l with\n| [] -&gt; a:[]\n| x:xs -&gt;\n  (match Nat.leb a x with\n   | True -&gt; a:l\n   | False -&gt; x:(insert a xs))\n\n(** val insertion_sort : Int ([]) -&gt; Int ([]) **)\n\nlet rec insertion_sort = function\n| [] -&gt; []\n| x:xs -&gt; insert x (insertion_sort xs)</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>module Nat :\n sig\n  val leb : Int -&gt; Int -&gt; Bool\n end\n\nval insert : Int -&gt; Int ([]) -&gt; Int ([])\n\nval insertion_sort : Int ([]) -&gt; Int ([])</pre>\n\n\n<p>lebも作ってくれるのか。\nまあないとコードにならないもんな。</p>\n\n<h2>証明駆動開発のステップ</h2>\n\n<ol>\n<li>まず書こうとしているプログラムがどういう性質をみたすべきかを記述し、</li>\n<li>Coq でそれをみたすようなプログラムを書き、</li>\n<li>実際に最初に考えた性質を証明し、</li>\n<li>Extraction して他の言語のコードに変換する</li>\n</ol>\n\n\n<h2>感想</h2>\n\n<p>形式証明が慣れてないからなのかとても難しかった。<br>\nただ、証明のステップを追うのはとても気持ちよかった。<br></p>\n\n<p>次は、最近発売された純粋関数型データ構造読むかなって気分。<br>\nSML で書かれているらしいから、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a> に置き換えながら写経するのが楽かな？<br>\nそれとも付録に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> 実装があるらしいので <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Haskell\">Haskell</a> に置き換えながら写経して、書けたら答え合わせするほうがいいかな。<br>\n悩ましい。</p>\n\n","slug":"プログラミング Coq (証明駆動開発 2)"},{"data":{"title":"技術書典2に行ってきた","published":"2017/04/09"},"content":"\n<p>お昼頃に予定があったので行くか迷っていたが、14時くらいには空いてきたということで技術書典2に行ってきた。</p>\n\n<p>目当ての一つだったインターネットの闇さんの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の本は既に完売と向かってる最中の電車の中で知る。\nCoqに興味があったのでCoqによる定理証明が買えるといいなと思いながら突入。</p>\n\n<p>16時過ぎでもう終わりかけなのになかなか賑わっていた。\n案の定、既に完売で何も片付けられているスペースもチラホラと。\nCoqによる定理証明のスペースを見つけたので、中身を見させてもらいながらCoqについて色々と教えていただいた。\n入門書かと思っていたけど違った。\n３部出ているうちの、一番簡単そうな2014年出版のものを買った。\nまずは入門して、そして読まねば。</p>\n\n<p>その後ぶらぶらしていたら、インターネットの闇さんのスペースを見つけたので、見本を見させてもらいながら色々話した。\n見本に載っている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OCaml\">OCaml</a>のコードはとても読みやすかったので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%C5%BB%D2%BD%F1%C0%D2\">電子書籍</a>版を期待していると伝え、またフラフラと。</p>\n\n<p>移動してすぐに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Fortran\">Fortran</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\">オブジェクト指向</a>プログラミングをするという尖ったことをしているところで声をかけられて <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Fortran\">Fortran</a> の話を聞いた。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Fortran\">Fortran</a> については、科学技術計算で主に使用されていることと、現在使われている<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語</a>の中で最も古い言語の一つってことくらいしか知らなかったのでおもしろかった。\n結局バグを減らしたかったり、大学みたいに人が入れ替わる環境だと既存のコードがすぐにレガシーになるので、可読性を高めたいということだった。\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Fortran\">Fortran</a>自体に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A5%D6%A5%B8%A5%A7%A5%AF%A5%C8%BB%D8%B8%FE\">オブジェクト指向</a>が導入されたのはFortran2003かららしいが、ユーザが少ないらしく最適化が後回しにされたりすることもあるらしい。\n自分が実際に触ることはないだろうけど、知らない言語の話を聞くのは面白かった。\n入門部分も書かれているという第一部を買った。\n速習する部分があったので、そこくらいは読んでおきたい。</p>\n\n<p>出不精なので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BD%A9%CD%D5%B8%B6\">秋葉原</a>までの遠出はつらかったが、普段聞けないことを色々聞けてよかった。</p>\n\n","slug":"技術書典2に行ってきた"},{"data":{"title":"Pathname#joinの不思議な挙動","published":"2017/01/12","tags":["ruby"]},"content":"\n<p>空のPathname同士をjoinした時に期待と違う挙動があった。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink> $ ruby -v\nruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin16]</pre>\n\n\n<p>期待していたのは次の動作。</p>\n\n<pre class=\"code lang-ruby\" data-lang=\"ruby\" data-unlink>path = <span class=\"synType\">Pathname</span>.new(<span class=\"synSpecial\">''</span>)         <span class=\"synComment\"># =&gt; #&lt;Pathname:&gt;</span>\npath.join(path)                 <span class=\"synComment\"># =&gt; #&lt;Pathname:&gt;</span>\n</pre>\n\n\n<p>でも実際はこうなっていた。</p>\n\n<pre class=\"code lang-ruby\" data-lang=\"ruby\" data-unlink>path = <span class=\"synType\">Pathname</span>.new(<span class=\"synSpecial\">''</span>)         <span class=\"synComment\"># =&gt; #&lt;Pathname:&gt;</span>\npath.join(path)                 <span class=\"synComment\"># =&gt; #&lt;Pathname:.&gt;</span>\n</pre>\n\n\n<p>空のPathnameと空のPathnameをjoinしてるんだから空のPathnameが欲しかったのに、 <code>.</code> がどこからか出てきてる。<br/>\nなぜこうなっているんだろう。</p>\n\n","slug":"Pathname#joinの不思議な挙動"},{"data":{"title":"剰余を使わないFizzBuzz","published":"2016/11/25","tags":["Haskell"]},"content":"\n<p>先日ESMで開かれた<a href=\"https://yochiyochihs.doorkeeper.jp/events/54217\">よちよち.hs</a>に参加しました．<br/>\nそこで剰余を使わずにzip3と無限リストを使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/FizzBuzz\">FizzBuzz</a>を書く話があったので書いてみました．</p>\n\n<pre class=\"code lang-haskell\" data-lang=\"haskell\" data-unlink>fizzbuzz <span class=\"synStatement\">=</span> map fizzbuzz' <span class=\"synStatement\">$</span> zip3 [<span class=\"synConstant\">1</span><span class=\"synStatement\">..</span>] (cycle [<span class=\"synConstant\">&quot;&quot;</span>,<span class=\"synConstant\">&quot;&quot;</span>,<span class=\"synConstant\">&quot;Fizz&quot;</span>]) (cycle [<span class=\"synConstant\">&quot;&quot;</span>, <span class=\"synConstant\">&quot;&quot;</span>, <span class=\"synConstant\">&quot;&quot;</span>, <span class=\"synConstant\">&quot;&quot;</span>,<span class=\"synConstant\">&quot;Buzz&quot;</span>])\n  <span class=\"synType\">where</span> fizzbuzz' (_, <span class=\"synConstant\">&quot;Fizz&quot;</span>, <span class=\"synConstant\">&quot;Buzz&quot;</span>) <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;FizzBuzz&quot;</span>\n        fizzbuzz' (_, <span class=\"synConstant\">&quot;Fizz&quot;</span>, _) <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;Fizz&quot;</span>\n        fizzbuzz' (_, _, <span class=\"synConstant\">&quot;Buzz&quot;</span>) <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;Buzz&quot;</span>\n        fizzbuzz' (n, _, _) <span class=\"synStatement\">=</span> show n\n</pre>\n\n\n\n\n<pre class=\"code\" data-lang=\"\" data-unlink>*Main&gt; take 100 fizzbuzz\n[&#34;1&#34;,&#34;2&#34;,&#34;Fizz&#34;,&#34;4&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;7&#34;,&#34;8&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;11&#34;,&#34;Fizz&#34;,&#34;13&#34;,&#34;14&#34;,&#34;FizzBuzz&#34;,&#34;16&#34;,&#34;17&#34;,&#34;Fizz&#34;,&#34;19&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;22&#34;,&#34;23&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;26&#34;,&#34;Fizz&#34;,&#34;28&#34;,&#34;29&#34;,&#34;FizzBuzz&#34;,&#34;31&#34;,&#34;32&#34;,&#34;Fizz&#34;,&#34;34&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;37&#34;,&#34;38&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;41&#34;,&#34;Fizz&#34;,&#34;43&#34;,&#34;44&#34;,&#34;FizzBuzz&#34;,&#34;46&#34;,&#34;47&#34;,&#34;Fizz&#34;,&#34;49&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;52&#34;,&#34;53&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;56&#34;,&#34;Fizz&#34;,&#34;58&#34;,&#34;59&#34;,&#34;FizzBuzz&#34;,&#34;61&#34;,&#34;62&#34;,&#34;Fizz&#34;,&#34;64&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;67&#34;,&#34;68&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;71&#34;,&#34;Fizz&#34;,&#34;73&#34;,&#34;74&#34;,&#34;FizzBuzz&#34;,&#34;76&#34;,&#34;77&#34;,&#34;Fizz&#34;,&#34;79&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;82&#34;,&#34;83&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;,&#34;86&#34;,&#34;Fizz&#34;,&#34;88&#34;,&#34;89&#34;,&#34;FizzBuzz&#34;,&#34;91&#34;,&#34;92&#34;,&#34;Fizz&#34;,&#34;94&#34;,&#34;Buzz&#34;,&#34;Fizz&#34;,&#34;97&#34;,&#34;98&#34;,&#34;Fizz&#34;,&#34;Buzz&#34;]</pre>\n\n\n<p>無限リストが扱いやすくていいですね．<br/>\nこういう書き方もあったとは</p>\n\n","slug":"剰余を使わないFizzBuzz"},{"data":{"title":"Rollbarでbotが出すエラーを無視する","published":"2016/10/19","tags":["Rollbar"]},"content":"\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/bot\">bot</a>から既に削除されたURLへのアクセスがあり，Rollbarのエラーログのノイズがひどかったので，<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/bot\">bot</a>からのアクセスで起こった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ActiveRecord\">ActiveRecord</a>::RecordNotFoundを無視する設定を書きました．</p>\n\n<p>上部のバーからSettingsをクリックします．\n<a href=\"https://gyazo.com/0de19f13528995a168e36aeb10adc72b\"><img src=\"https://i.gyazo.com/0de19f13528995a168e36aeb10adc72b.png\" alt=\"https://gyazo.com/0de19f13528995a168e36aeb10adc72b\" /></a></p>\n\n<p>次に画面左からGroupingをクリック．\n<a href=\"https://gyazo.com/991020fcbc82e6e917285dcafbbf5a14\"><img src=\"https://i.gyazo.com/991020fcbc82e6e917285dcafbbf5a14.png\" alt=\"https://gyazo.com/991020fcbc82e6e917285dcafbbf5a14\" /></a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/json\">json</a>でCustom Groupを定義します．\n<a href=\"https://gyazo.com/3f613693a8210aed7ea79e12f3674b08\"><img src=\"https://i.gyazo.com/3f613693a8210aed7ea79e12f3674b08.png\" alt=\"https://gyazo.com/3f613693a8210aed7ea79e12f3674b08\" /></a></p>\n\n<p>ボットからのアクセスで起こった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ActiveRecord\">ActiveRecord</a>::RecordNotFoundをグルーピングするには次のような<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/json\">json</a>で定義できます．</p>\n\n<pre class=\"code lang-json\" data-lang=\"json\" data-unlink><span class=\"synSpecial\">[</span>\n  <span class=\"synSpecial\">{</span>\n    &quot;<span class=\"synStatement\">title</span>&quot;: &quot;<span class=\"synConstant\">Bot error</span>&quot;,\n    &quot;<span class=\"synStatement\">fingerprint</span>&quot;: &quot;<span class=\"synConstant\">bot-error</span>&quot;,\n    &quot;<span class=\"synStatement\">condition</span>&quot;: <span class=\"synSpecial\">{</span>\n      &quot;<span class=\"synStatement\">all</span>&quot;: <span class=\"synSpecial\">[</span>\n        <span class=\"synSpecial\">{</span> &quot;<span class=\"synStatement\">path</span>&quot;: &quot;<span class=\"synConstant\">request.headers.User-Agent</span>&quot;,\n          &quot;<span class=\"synStatement\">in</span>&quot;: <span class=\"synSpecial\">[</span>\n            &quot;<span class=\"synConstant\">Mozilla/5.0 (compatible; AhrefsBot/5.1; +http://ahrefs.com/robot/)</span>&quot;,\n            &quot;<span class=\"synConstant\">Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)</span>&quot;,\n            &quot;<span class=\"synConstant\">Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span>&quot;,\n            &quot;<span class=\"synConstant\">Mozilla/5.0 (iPhone; CPU iPhone OS 7_0 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A465 Safari/9537.53 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)</span>&quot;,\n            &quot;<span class=\"synConstant\">Mozilla/5.0 (compatible; Exabot/3.0; +http://www.exabot.com/go/robot)</span>&quot;\n          <span class=\"synSpecial\">]</span>\n        <span class=\"synSpecial\">}</span>,\n        <span class=\"synSpecial\">{</span> &quot;<span class=\"synStatement\">path</span>&quot;: &quot;<span class=\"synConstant\">body.trace.exception.class</span>&quot;,\n          &quot;<span class=\"synStatement\">eq</span>&quot;: &quot;<span class=\"synConstant\">ActiveRecord::RecordNotFound</span>&quot; <span class=\"synSpecial\">}</span>\n      <span class=\"synSpecial\">]</span>\n    <span class=\"synSpecial\">}</span>\n  <span class=\"synSpecial\">}</span>\n<span class=\"synSpecial\">]</span>\n</pre>\n\n\n<p>このpathはOccurrenceのRawJSONで出力されているログのパス。\nリファレンスはこちら。\nin以外にもeqやcontainなどがあります．</p>\n\n<p><a href=\"https://rollbar.com/docs/custom-grouping/\">https://rollbar.com/docs/custom-grouping/</a></p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JSON\">JSON</a>が書けたら入力欄左下にあるボックスにoccurrence IDを入力してマッチさせたいエラーにマッチするか確認できます．\n<a href=\"https://gyazo.com/fa47f8f31caf1ed6cd28c083010b112f\"><img src=\"https://i.gyazo.com/fa47f8f31caf1ed6cd28c083010b112f.png\" alt=\"https://gyazo.com/fa47f8f31caf1ed6cd28c083010b112f\" /></a></p>\n\n<p> 次にエラーが起こると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Bot\">Bot</a> errorとしてグルーピングされるのでそれをmuteすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Dashboard\">Dashboard</a>に表示されなくなります．\n逆に特定のエラーグループのlevelをwarningからcriticalに上げることもできたりもします．</p>\n\n","slug":"Rollbarでbotが出すエラーを無視する"}],"page":1},"__N_SSG":true}