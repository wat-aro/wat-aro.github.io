{"pageProps":{"slide":{"title":"パイプライン演算子","published":"2019/06/20","tags":["Functional Programming","Ruby"],"slug":"pipeline-operator","content":"## パイプライン演算子\n\nwat-aro\n\n---\n\n### パイプライン演算子\n\nこんな感じのやつ\n\n```elm\n  [1, 2, 3]\n  |> List.map (\\x -> x * 2)\n  |> List.foldl (+)\n```\n\n---\n\n#### パイプライン演算子\n\n`|>` の前の値を関数に適用する\n\n---\n\n#### パイプライン演算子\n\n- 元は Isabela/ML あたりが発祥\n- F# が採用\n- OCaml が採用\n- Elixir が F# から採用\n- Ruby に入りそう\n\n---\n\n---\n\n### ML などにおけるパイプライン演算子のつくりかた\n\n以下を満たせば簡単につくれる\n\n- ユーザ定義演算子\n- デフォルトでカリー化\n\n---\n\n#### Haskell でのつくり方\n\n第一引数を第二引数に適用するだけ\n\n```haskell\n(|>) :: a -> (a -> b) -> b\n(|>) a f = f a\n```\n\n---\n\n---\n\n### カリー化と部分適用\n\n以降の話に関わるのでここでおさらい\n\n---\n\n#### カリー化\n\n複数の引数を受け取る関数を一引数の関数に変換する\n\n```haskell\nuncuffyFunction :: (a, b, c) -> d\nuncuffyFunction (a, b, c) = somethingToDo a b c\n\ncurriedFunction :: a -> b -> c -> d\ncurriedFunction a b c = somethingToDo a b c\n```\n\n---\n\n#### ES6\n\n```js\nconst uncurryFunction = (a, b, c) => somethigTodo(a, b, c);\n\nconst curriedFunction = (a) => (b) => (c) => somethingTodo(a, b, c);\n```\n\ncurriedFunction は引数を一つとると残りの引数を _一つずつ取る関数_ を返す\nuncurry な関数を curried な関数に変換するのが\n\n---\n\n### 部分適用\n\n複数の引数を取る関数で、一部にだけ引数を適用した状態の関数を返す。\n\n```js\nconst partialApplied = somethigTodo(1, 2, ?);\n```\n\n---\n\n### なぜカリー化と部分適用の話を？\n\nElixir などのデフォルトでカリー化されていない言語では関数のようにパイプライン演算子を定義できない\ne.g.\n\n- Elixir, Clojure はマクロ\n- Ruby は言語組み込みの機構\n\n---\n\n---\n\n### Elixir のパイプライン演算子\n\nML 系は関数の最後の引数に値を差し込む\nElixir は最初の引数を差し込む\n\n---\n\n#### Elixir の |>\n\n```elixir\n[1, [[2], 3]]\n  |> List.flatten\n  |> Enum.map(fn x -> x * x end)\n  |> Enum.reduce(0, fn(x, acc) -> x + acc end)\n```\n\n---\n\n#### Elixir の |>\n\nカリー化されていないため AST を変換する必要がある\n\n---\n\n---\n\n### Ruby のパイプライン演算子\n\nパイプラインといいつつただの優先度の低い `.`\n\n---\n\n#### Ruby のパイプライン演算子\n\n```ruby\n(1..5).map {|x| x * 2 }\n\n1..5 |> map {|x| x * 2 }\n```\n\nのように書ける\n\n---\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n[![Image from Gyazo](https://i.gyazo.com/4ecb8454c6bfc9d8470cb6c118129d21.png)](https://twitter.com/hanachin_/status/1139406434846695430)()\n\nこれの話をしたかった\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n```\n\n`.:` は Ruby 2.7 で入る演算子。\nMethod オブジェクトを取り出す。\nMethod オブジェクトはほぼ Proc オブジェクトと同じふるまい。\n詳しくはドキュメントを読んでください。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n```\n\n`URI.parse` でなく `URI.:parse` に注意。\nとりだした Method オブジェクトを `|>` と `>>` で合成する。\n`>>` は Ruby2.6 で入った関数(Proc)合成演算子。\n`URI.:parse` で `URI.parse` の Method オブジェクトを取りだし、\n`>>` によって合成している。\nつまり\n\n```ruby\nURI.parse(\"https://api.github.com/repos/ruby/ruby \")\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n  |>>> Net::HTTP.:get\n```\n\n`Net::HTTP.:get` で `Net:HTTP.get` の Method オブジェクトを取り出す。\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nNet::HTTP.get(uri)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n  |>>> Net::HTTP.:get\n  |>>> JSON.:parse\n```\n\nここでも `JSON.:parse` で `JSON.parse` で Method オブジェクトを取り出す\n\n```ruby\nuri = URI.parse(\"https://api.github.com/repos/ruby/ruby \")\nresponse = Net::HTTP.get(uri)\nJSON.parse(response)\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n  |>>> Net::HTTP.:get\n  |>>> JSON.:parse\n  |> call\n```\n\n今までは Method オブジェクトを合成しただけなので、ここでやっと評価され、値になる。\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n  |>>> Net::HTTP.:get\n  |>>> JSON.:parse\n  |> call\n  |> fetch(\"stargazers_count\")\n```\n\n`Hash#fetch` で値を取りだす\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\n```ruby\n\"https://api.github.com/repos/ruby/ruby \".:itself\n  |>>> URI.:parse\n  |>>> Net::HTTP.:get\n  |>>> JSON.:parse\n  |> call\n  |> fetch(\"stargazers_count\")\n  |> then { puts @1 }\n```\n\nそして標準出力へ。\n`@1` は Ruby2.7 で入る予定。\n\n```ruby\n\"hoge\".then { puts @1 }\n\"hoge\".then {|s| puts s }\n```\n\n---\n\n#### Ruby のパイプライン演算子における応用\n\nたーのしー\n\n---\n\n---\n\n### まとめ\n\nパイプライン演算子の説明\nRuby2.7 で入る予定のパイプライン演算子とその応用の紹介\n関数合成をキメていこう\n\n---\n\n#### 悲しみ\n\n[![Image from Gyazo](https://i.gyazo.com/47e87c4f7f7ad60bb2f657b4ebbf431b.png)](https://twitter.com/hanachin_/status/1139406434846695430)\n\n---\n\nもっと詳しく知りたい人は\n\n[パイプライン演算子の歴史 - まめめも](https://mametter.hatenablog.com/entry/2019/06/15/192311)\n[第一引数版パイプライン演算子 - Qiita @cedretaber](https://qiita.com/cedretaber/items/6a3831367439f64756ab)\n"}},"__N_SSG":true}